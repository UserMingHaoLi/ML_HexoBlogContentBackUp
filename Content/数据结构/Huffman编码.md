---
title: Huffman编码
date: 2021-08-29 15:24:00
updated: 2021-08-29 15:24:00
id: ml-20210829-152400-g155
categories:
	- 数据结构
tags: 
	- 数据结构
---

首先讲个算法

# 固定长度编码

即,将明文`abcdefg`中每个数给一个固定长度的密文  

a = 000  
b = 001  
以此类推

此时若有10万个明文,则需要30w的存储空间

<!--more-->

# 可变长度面吧

根据统计的单个明文出现概率,使概率越高的字符越短

a = 0
b = 101
f = 1100

如此便可节省一些空间

> 注意,此编码需要遵守`前缀编码`规则, 即没有一个编码是其他编码的前缀, 不然则有可能造成混淆

# Huffman编码

根据规则`若是0则左子节点,若是1则右子节点`  

首先,我们初始化数据. 将集合内的元素按照出现次数从小到大排序,且记录他们的出现次数  

```
[F=5次, e=9, c=12, b=13, d=16, a=45]
```

现在开始编码

虚构一个根节点`Z`  
将列表中第一个数据作为左子节点, 第二个数据作为右子节点

```
	Z
f=5		e=9
```

计算z的值为其子节点的和, 所以z=14.  
这里方便计算更名为`z1`. 后续的`z`节点都几作z2,z3,以此类推
并将z插入列表

```
[c=12, b=13, z1=14 d=16, a=45]
```

```
	z2
c=12		b=13
```

```
[z1=14 d=16, z2=25 a=45]
```

最终结果如下树
```
		z5=100
a=45				z4=55
			z2=25				z3=30
		c=12	b=13		z1=14	d=16
						f=5		e=9
```

此时编码就完成了, 若要知道每个位置的编码,则使用之前定义的规则`若是0则左子节点,若是1则右子节点`

a是左子节点,得到0
f是右,右,左,左,得到1100

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
