---
title: Huffman编码
date: 2021-08-29 15:24:00
updated: 2021-08-29 15:24:00
id: ml-20210829-152400-g155
categories:
	- 数据结构
tags: 
	- 数据结构
---

首先讲个算法

# 固定长度编码

即,将明文`abcdefg`中每个数给一个固定长度的密文  

a = 000  
b = 001  
以此类推

此时若有10万个明文,则需要30w的存储空间

<!--more-->

# 可变长度面吧

根据统计的单个明文出现概率,使概率越高的字符越短

a = 0
b = 101
f = 1100

如此便可节省一些空间

> 注意,此编码需要遵守`前缀编码`规则, 即没有一个编码是其他编码的前缀, 不然则有可能造成混淆

# Huffman编码

根据规则`若是0则左子节点,若是1则右子节点`  

首先,我们初始化数据. 将集合内的元素按照出现次数从小到大排序,且记录他们的出现次数  

```
[F=5次, e=9, c=12, b=13, d=16, a=45]
```

现在开始编码

虚构一个根节点`Z`  
将列表中第一个数据作为左子节点, 第二个数据作为右子节点

```
	Z
f=5		e=9
```

计算z的值为其子节点的和, 所以z=14.  
这里方便计算更名为`z1`. 后续的`z`节点都几作z2,z3,以此类推
并将z插入列表

```
[c=12, b=13, z1=14 d=16, a=45]
```

```
	z2
c=12		b=13
```

```
[z1=14 d=16, z2=25 a=45]
```

最终结果如下树
```
		z5=100
a=45				z4=55
			z2=25				z3=30
		c=12	b=13		z1=14	d=16
						f=5		e=9
```

此时编码就完成了, 若要知道每个位置的编码,则使用之前定义的规则`若是0则左子节点,若是1则右子节点`

a是左子节点,得到0
f是右,右,左,左,得到1100

# 扩展

## 满二叉树

国内一般指`一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树`  
国际一般定义`如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树`  

## 完全二叉树

树中的结点按从上至下、从左到右的顺序进行编号  
编号为`i`的结点与 满二叉树 中编号为`i`的结点在二叉树中的位置相同

可得,满二叉树是完全二叉树, 完全二叉树不一定是满二叉树.  

> Huffman树又称`最优二叉树`. 是因为他的带权路径长最小  
> 节点的带权路径长指的是叶子节点的权值与路径长的乘积,树的带权路径长即为树中所有叶子节点的带权路径长度之和  
> 由此可知，若叶子节点的权值都是已知的，则二叉树的构造过程中，使得权值越大的叶子节点路径越小，则整棵树的带权路径长最小

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
