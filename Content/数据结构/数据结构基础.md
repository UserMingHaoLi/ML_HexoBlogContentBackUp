---
title: 数据结构基础
date: 2021-09-02 01:04:00
updated: 2021-09-02 01:04:00
id: ml-20210902-010400-g157
categories:
	- 数据结构
tags: 
	- 数据结构
---

数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率

# 定义

数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构

数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义

上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程

> 数据结构可以抽象的解决一类问题,是实现算法的基础  
> 数据结构和算法, 让我们回归计算本质, 计算机只是工具

<!--more-->

逻辑关系是指数据元素之间的前后间关系

1. 集合
2. 线性
3. 树
4. 图
5. ...

指数据的逻辑结构在计算机存储空间的存放形式

1. 顺序
2. 链接
3. 索引
4. 散列

# 常用的数据结构

* 数组(Array)
* 栈( Stack)
* 队列(Queue)
* 链表( Linked List)
* 树( Tree)
* 图(Graph)
* 堆(Heap)
* 散列表(Hash)

# 常用算法

* 检索
* 插入
* 删除
* 更新
* 排序

# 绳索计算机

计算机只是计算的工具  

取12段等长的绳索,首尾链接成环状.  
从任意节点A出发,走4节为B点,再取另一方向3节为C点.  
从ABC三点拉直绳索,便可得到一个直角`∠A`  

此时,绳索就是计算机, 任何情况都能得到直角的技巧就是算法.  

> 勾股定理

# 尺规计算器

输入任意线段, 输出他的两个点,使其可以三等分 

从A出发任意方向一条不与AB重合的射线p  
取p上三个点D1,C1,B1, 使 AD1 = D1C1 = C1B1

链接``` BB1 ```  
经过D1 做 BB1 的平行线, 交AB与D
经过C1 做 BB1 的平行线, 交AB与C

此时可得DC两点即为三等分点.

> 子程序: 过直线外一点,做平行线  
> 算法之间有包含关系

# 什么是计算

计算 = 信息处理

即: 借助某种工具,准寻一定规则,以明确而机械的方式运转进行.并给出结果

所以算法是指:给定计算模型情况下,解决特定问题的指令序列  
包含`输入`,`输出`.  
满足`正确性`,`确定性`,`可行性`.`又穷性`.

> 当然,还有很多额外定义,不过了解以上这些就足够了

## 又穷性

对于一个冰雹算法(n/2 | 3+1). 我们不能得知他是否又穷.  
因为他需要满足所有的`n`. 

> 扩展:死循环或栈溢出

# 什么是一个好算法

* 简单
* 大规模
* 一般或异常
* 可退化
* 能处理任何输入
* 健壮
* 可读

> 但这些都不是最重要的  

我们需要追求的是**效率**  
即:速度尽可能快,存储空间尽可能小  

> 很多时候,我们需要在速度或者空间中的一方做出让步,换取另一方的提升.

# 度量效率(性能测度)

> 了解这个世界最好的方式就是测量他(的某一方面).  
> 如果你需要改进某样东西,你就要取测量他

所以,对于算法,我们需要计算他的成本(时间成本, 空间成本)  
然后得出度量规则, 并进行比较

使用算法A求解实例P,记作Ta(P)  
但这个定义意义不大, 因为实例可能以偏概全,毕竟可能的实例太多了

# 问题规模

成本,大部分情况下都与规模呈正相关

零Ta(n) = 用特定算法A求解某一类问题规模为n的实例, 所需计算成本

讨论特定算法A时, 记作T(n)

> 但是, 即使是同一问题,且等规模,任然有太多其他因素影响效率

比如求解一个问题时有可能直接求出一个不可能更优的值, 所以并不能代表效率

> 所以我们对于算法,只关注最坏(成本最高)情况, 即最后一个才能找到  

取 T(n) = max{ T(P) | |P| = n}

# 理想模型

如果只进行实验,则不够全面.  

* 规模
* 类型
* 程序员,语言,编译器
* 选项,结构,系统

*所以我们需要抽象出一种理想的平台.或者模型*

# 图灵机

略

> 我们可以将图灵机作为这种理想平台,用于评判效率

# 大O记号

我们关心足够打的问题,且更关心他的增长趋势  
即:问题规模变大,成本如何提升

最终我们得到一条曲线.

这就得到了我们需要的增长率

> 忽略常系数  
> 忽略低次项  
> 因为他们再增长的过程中,不占据主要地位,且越往后占比越小

## O(1)

不含有循环,分支,递归

> 实际上可以含有,但必须是极少量且增幅极少可被忽略的.

## O(Logn)

因为常数可以忽略, 所以Log100N可简化为LogN.同理所有常数都被忽略

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
