---
title: 数据结构基础
date: 2021-09-02 01:04:00
updated: 2021-09-02 01:04:00
id: ml-20210902-010400-g157
categories:
	- 数据结构
tags: 
	- 数据结构
---

数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率

# 定义

数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构

数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义

上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程

> 数据结构可以抽象的解决一类问题,是实现算法的基础  
> 数据结构和算法, 让我们回归计算本质, 计算机只是工具

<!--more-->

逻辑关系是指数据元素之间的前后间关系

1. 集合
2. 线性
3. 树
4. 图
5. ...

指数据的逻辑结构在计算机存储空间的存放形式

1. 顺序
2. 链接
3. 索引
4. 散列

# 常用的数据结构

* 数组(Array)
* 栈( Stack)
* 队列(Queue)
* 链表( Linked List)
* 树( Tree)
* 图(Graph)
* 堆(Heap)
* 散列表(Hash)

# 常用算法

* 检索
* 插入
* 删除
* 更新
* 排序

# 绳索计算机

计算机只是计算的工具  

取12段等长的绳索,首尾链接成环状.  
从任意节点A出发,走4节为B点,再取另一方向3节为C点.  
从ABC三点拉直绳索,便可得到一个直角`∠A`  

此时,绳索就是计算机, 任何情况都能得到直角的技巧就是算法.  

> 勾股定理

# 尺规计算器

输入任意线段, 输出他的两个点,使其可以三等分 

从A出发任意方向一条不与AB重合的射线p  
取p上三个点D1,C1,B1, 使 AD1 = D1C1 = C1B1

链接``` BB1 ```  
经过D1 做 BB1 的平行线, 交AB与D
经过C1 做 BB1 的平行线, 交AB与C

此时可得DC两点即为三等分点.

> 子程序: 过直线外一点,做平行线  
> 算法之间有包含关系

# 什么是计算

计算 = 信息处理

即: 借助某种工具,准寻一定规则,以明确而机械的方式运转进行.并给出结果

所以算法是指:给定计算模型情况下,解决特定问题的指令序列  
包含`输入`,`输出`.  
满足`正确性`,`确定性`,`可行性`.`又穷性`.

> 当然,还有很多额外定义,不过了解以上这些就足够了

## 又穷性

对于一个冰雹算法(n/2 | 3+1). 我们不能得知他是否又穷.  
因为他需要满足所有的`n`. 

> 扩展:死循环或栈溢出

# 什么是一个好算法

* 简单
* 大规模
* 一般或异常
* 可退化
* 能处理任何输入
* 健壮
* 可读

> 但这些都不是最重要的  

我们需要追求的是**效率**  
即:速度尽可能快,存储空间尽可能小  

> 很多时候,我们需要在速度或者空间中的一方做出让步,换取另一方的提升.

# 度量效率(性能测度)

> 了解这个世界最好的方式就是测量他(的某一方面).  
> 如果你需要改进某样东西,你就要取测量他

所以,对于算法,我们需要计算他的成本(时间成本, 空间成本)  
然后得出度量规则, 并进行比较

使用算法A求解实例P,记作Ta(P)  
但这个定义意义不大, 因为实例可能以偏概全,毕竟可能的实例太多了

# 问题规模

成本,大部分情况下都与规模呈正相关

零Ta(n) = 用特定算法A求解某一类问题规模为n的实例, 所需计算成本

讨论特定算法A时, 记作T(n)

> 但是, 即使是同一问题,且等规模,任然有太多其他因素影响效率

比如求解一个问题时有可能直接求出一个不可能更优的值, 所以并不能代表效率

> 所以我们对于算法,只关注最坏(成本最高)情况, 即最后一个才能找到  

取 T(n) = max{ T(P) | |P| = n}

# 理想模型

如果只进行实验,则不够全面.  

* 规模
* 类型
* 程序员,语言,编译器
* 选项,结构,系统

*所以我们需要抽象出一种理想的平台.或者模型*

# 图灵机

略

> 我们可以将图灵机作为这种理想平台,用于评判效率

# 大O记号

我们关心足够打的问题,且更关心他的增长趋势  
即:问题规模变大,成本如何提升

最终我们得到一条曲线.

这就得到了我们需要的增长率

> 忽略常系数  
> 忽略低次项  
> 因为他们再增长的过程中,不占据主要地位,且越往后占比越小

## O(1)

不含有循环,分支,递归

> 实际上可以含有,但必须是极少量且增幅极少可被忽略的.

## O(Logn)

因为常数可以忽略, 所以Log100N可简化为LogN.同理所有常数都被忽略

## O(n²)

此处的2可替换为任意数x. 总是取多项式中最大的项,理由同上

> 难解:颠倒以下为 2的N次方. 此时增长太快,被认为不可容忍 ,也叫指数复杂度  
> 此类算法一般认为是无效算法的起点 

> 很多算法的`2的N次方`解很同意的出,但想要优化为`O(n²)`则非常难,甚至是无解

## 难解举例

美国大选共计51个投票区共计538票,是否可能存在一个投票方法使两个候选人得票相同(每人269票)

> 典型的两个子集划分问题,这是一个`NP-Complete`问题.即目前计算模型而言最少也是难解级别

# 复杂度计算

## 级数

即典型的`1+2+...+n` = `n(n+1)/2`,此为`O(n²)`. 对于末尾n本来就是多次方的情况,也可以用此式子表示

`几何级数`则取末尾即可, 因为较小的次方可以忽略  
`1+2+4+...+2的N次方` = `O(2的N次方)`

`收敛级数` = `O(1)`  
`1/1 + 1/2 + ... + 1/n`

`调和级数` = `O(Logn)`  
和`收敛级数`类似,但不收敛,只是长度有限

`对数级数` = `O(nLogn)` 
`log1 + log2 + .. +logn`

## 循环

两个典型

```
for(i=0;i<n;i++)
for(j=0;j<n;j++)
	Op();
```

```
for(i=0;i<n;i++)
for(j=0;j<i;j++)
	Op();
```

直觉看上去应该下面的小些,实际他们都是`O(n²)`  

我们可以吧i和j作为横纵轴,前者是一个矩形,后者是一个三角形.但他们都是`O(n²)` 增长

> 一旦循环中的一项从`i++`调整为`i = i²`则复杂度简化为`O(n)` 

## 冒泡排序

> 排序我们一般成为升序或者降序,实际上默认算法一般是升序的,学名应该叫`非降`排序,因为容忍相等

同上面循环的案例,冒泡排序是`O(n²)`

问:冒泡排序是否可以终止且给出正确结果.
答:可以,如下证明

* 不变性:经过K轮扫描交换后,最大的K个元素必然就位
  * 因为每次扫描必然将一个最大的元素移动至末尾
* 单调性:经过K轮扫描后,问题规模缩减到n-k
  * 因为每次扫描都是末尾K个元素为有序,且不再参与和影响后续算法
* 正确性:经过至多n轮扫描后,必然终止且给出正确结果
  * 结合上两个推到而出

> 算法是思路,具体编码的Bug暂不考虑

## 封底估算

由于精度可以忽略级数较低的部分,所以估算一下也能得出准确的结论

在两个城市各打一口井,在一个城市阳光正射时记录另一个城市的阴影偏转角度(由于太阳距离过远,阳光近似为平行过来的)  
通过角度/360得出两城市距离和地球周长的比值,便可求出地球周长,这样测量实际也上不会比现代科技工具差上一个数量级.实际当时计算结果为`39350`,现在结果为`40076`差别小于2%;

> 所以我们很多时候可以估算

### 例子

一天 = `24 * 60 *60` 即 `24*3600`

我们将其近似为`25*4000`,则为`10的5次方秒`

一世纪 = 100年 = 365*100, 近似为`3*10的4次方`天, 根据上面的天/秒结果  
得出一世纪 = `3*10的9次方`秒

则三生三世 = 300年 近似为`10的10次方`秒

宇宙大爆炸至今≈`10的21次方`秒

> 实际1天=86400秒,一年(365天)=3153600秒,一百年=315360000,三百年=946080000秒  
> 可以看到误差还可以

> 然后可以简化记忆, 在三生三世中的一天,可以看作一天中的一秒(`10的10次方`中的`10的5次方`,也就是5个数量级,刚好`10的5次方`也是5个数量级)
> 宇宙大爆炸中的三生三世,可以看作三生三世中的0.1秒(`10的21次方`中的`10的10次方`也就是11个数量级,`10的10次方`是10个数量级,换算为0.1)

## 递归和迭代

初学时我们认为递归优于迭代,但算法层面迭代效率往往更好

## 分治

求和计算

`1+2+...+n`

很明显是`O(n)`

> 对于空间复杂度,我们一般只计算处输入外,因为算法额外添加的部分  
> 此处为`O(2)`(计数器i和结果Sum),也就是`O(1)`

### 减而治之

对于一个问题,将其分解为一个更小规模的子问题,和一个可以求解的平凡问题, 而小问题的本质与之前的大问题相同,所以也可以如此分下去. 最终可以得出解.

> 此时递归效率是`O(n)`,也叫线性递归  
> 推算过程如下`T(n) = T(n-1) + O(1)`,且`T(0)=O(1)`. 所以有n+1个`O(1)`,得出`O(n)`

### 二分递归

我们将每个问题分为两个一样大的问题(由于奇数,可能其中一个稍大1)

> 此时问题变为以2为倍数的几何级数

问题变为`2的0次方+2的1次方+...+2的logn次方`, 最后结果`O(n)`

更快速的求解方式如下  
问题实际上是从`T(n)`分解为`2 * T(n/2)`.最终分下去还是`O(n)`

> 一般,对于下界限lo和上界限hi,我们有[lo,hi), 即包含lo但不包含hi(只包含hi-1)  
> 这样我们思考更简便些

#### Max2问题

对于一个数列中寻找最大的两个值

最坏的方法是比较两次, 需要O(2n-3)  
然后是维护两个指针来只比较一次, 需要O(n-1)  
最后可以分治,为O(5n/3-2)

> 注意,此时二分的最小单位为3个(因为是求Max2,且三个不能分成两个Max2). 而且只需要4个结果中的三个参与比较(败者组的第二位直接不比较)

> 最后都是O(n), 没啥意思.  
> 后面还有更多算法可以提升效率,现在暂且不讲,关键字`锦标赛树`

# 做一个算法分为三步

1. 先让他工作
2. 让他正确工作
3. 提升效率

> 为了效率,舍弃递归选择迭代

对于一个式子`T(n) = T(n-1) + T(n-2) + 1, n>1`, 其中边界`T(0) = T(1) = 1`

> 这是一个斐波那契数列

不难看出,其效率为`2的N次方`, 实际效率其实是`(1+√5) / 2`约等于`1.61803的N次方`

指数的效率是非常慢的,主要原因在于其递归中有太多重复计算.  
所以只要记住结果以备查询,效率会好很多,这将使计算过的内容时间变为`O(1)`  
	* 而且只用记录最近两个即可.
然后再改为迭代算法, 从低到高逐步运算.

```C#
int f = 0;
int g = 1;
while(0 < n--)//n是迭代次数
{
	g = g + f;//等同于斐波那契+1
	f = g - f;//实际上就是计算前的g
	//也就是g和f都在斐波那契数列上+1
}
return g;
```

上面代码时间复杂度`O(n)`,空间复杂度`O(1)`

## 求公共子序列

现有两个字符串,要求求出其中公共子序列的长度  
一个字符串S，去掉零个或者多个元素所剩下的子串称为S的子序列。最长公共子序列就是寻找两个给定序列的子序列，该子序列在两个序列中以相同的顺序出现，但是不必要是连续的

```C#
//参数
string strRow = "ALGORITHMS";//参数1 作为每行第一个
string strCol = "ALCHEMIST";//参数2 作为每列第一个

//初始化,列和行各有一个空白位置(不用空白位置就多加条件判断,这里加空白看的清楚点)
int nTblRow = strRow.Length + 1;
int nTblCol = strCol.Length + 1;
int[,] resultTbl = new int[nTblRow, nTblCol];
//开头的空白行和空白列,计数器默认为0
for (int i = 0; i < nTblRow; i++)//可以使用`resultTbl.GetLength(0)`获取多为数组的相应Length
{
	resultTbl[i,0] = 0;
}
for (int i = 0; i < nTblCol; i++)
{
	resultTbl[0, i] = 0;
}

//计算, 从1开始,空白行和空白列不再计算
for (int i = 1; i < nTblRow; i++)
{
	for (int j = 1; j < nTblCol; j++)
	{
		char cRow = strRow[i - 1];//这里使用的是传入参数,没有空白,所以减去Tbl中空白的一个
		char cCol = strCol[j - 1];

		bool bEquals = cRow == cCol;//是否相等
		if (bEquals)
		{
			//取对角+1
			int nLeftTop = resultTbl[i-1, j-1];
			resultTbl[i, j] = nLeftTop + 1;
		}
		else
		{
			//取左或上的最大值
			int nLeft = resultTbl[i, j - 1];//左边其实就是列-1
			int nTop = resultTbl[i - 1, j];//上边就是行-1
			int nMax = Math.Max(nLeft, nTop);
			resultTbl[i, j] = nMax;
		}
	}
}

//输出,打印表格
int nPrintRow = nTblRow + 1;//打印还需要显示额外输入参数,所以再+1
int nPrintCol = nTblCol + 1;
char strSpace = ' ';//多语言?
for (int i = 0; i < nPrintRow; i++)
{
	for (int j = 0; j < nPrintCol; j++)
	{
		if (i == 0)
		{
			if(j - 2 < 0)
			{//前两个为空格
				Console.Write(strSpace);
			}
			else
			{//实际输入参数
				Console.Write(strCol[j - 2]);//当行为0时,逐步展示每列的第0个
			}
		}
		else if (j == 0)
		{
			if (i - 2 < 0)
			{
				Console.Write(strSpace);
			}
			else
			{
				Console.Write(strRow[i - 2]);
			}
		}
		else
		{
			Console.Write(resultTbl[i - 1, j - 1]);//非参数展示,输出结果
		}
	}
	Console.Write(Environment.NewLine);//当前环境的通用换行
}

Console.ReadLine();
```

输出结果如下

```C#
  ALCHEMIST
 0000000000
A0111111111
L0122222222
G0122222222
O0122222222
R0122222222
I0122222333
T0122222334
H0122333334
M0122334444
S0122334455
```

最终结果就是右下角的数字`5`;

> 最后,由于有结果集,所以是可回溯的.  
> 如有需求,可以输出所有子序列结果

# 动态规划

动态规划（Dynamic Programming）是一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。

基本思想：将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）  
与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次  
如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。通常可以用一个表来记录所有已解的子问题的答案  
不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路

采用动态规划求解的问题需要具有两个特性：

* 最优子结构（Optimal Substructure）：问题的一个最优解中所包含的子问题的解也是最优的。

* 重叠子问题（Overlapping Subproblems）：用递归算法对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。

动态规划的关键是 —— 记忆，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。

# 接口与实现

抽象数据结构,指模型上的一组操作  
数据结构,指基于某种语言,实现的一整套算法.

> 所以将操作抽象为接口

相邻逆序对数量,可以用于度量逆序程度

# 向量

向量是一组定义好的抽象数据结构, 最终被各种代码实现为可变长的数组.  
C#中是ArrayList,或者说IList

> 为什么采用容量加备策略  
> 对于一个Max的插入,递增效率达到O(n). 倍增则是O(1)  
> 这个效率是通过牺牲50%空间换来的.

# 平均复杂度

根据概率分布,将成本加权.   
割裂了操作的连贯性和关联性

# 分摊复杂度

对连续的数据结构实施多次操作, 所需的总成本  
实际角度考虑.  
更精准的判断真实性能

> 算法,数据结构的课程中,经常不对输入做判断或异常处理,这是为了教学方便,但实际运用时,这些是必须的.

# 有序

将数据变为有序后,相关算法的效率可以得到优化.

比如删除重复, 现在只需要一遍`O(n)`   
还有二分查找

> 一般的插入,删除等基本步骤,都要求有返回值,以便更好的参与其他算法,作为其组成部分  
> 否则,将成为孤立功能

```C#
V.Insert(1+V.Search(e), e);//同样的数据放在一起
```
*上述代码要求查找到`不大于e的元素的位置`*  

> 使用小于号`<`更可读, 可理解为从左到右,从小到大.

但是此算法向左侧比较一次, 而右侧为第二次,总体而言,需要O(1.5*Logn)

想要再次优化, 我们需要将左边更深,右边更浅,于是性能还能优化

这就是**斐波那契数列**, 左边的个数`fib(k-1)` 总是大于 `fib(k-2)`.

实际上就是精妙的取了一个中间值,二分法总是取`0.5`为中点,而fib则是`0.6180339...`, 此时常系数从`1.5`降低至`1.44042`左右

还有更好的一个办法, 即每次只判断一次, 所以左和右都只要一次即可深入一层. 但这样导致没法判断`==`,则每次都会使规模为1之后才能确认结果

后续在需要更优的算法,则需要容器内更详细的排列规则(方便推算更好的切分中点,甚至每次动态计算中点)  
但可能收到干扰和蒙骗, 推荐综合使用,如下  
* 大规模: 插值查找
* 中规模: 折半查找
* 小规模: 顺序查找

这样能确保精度,防止干扰,还可以有效提升效率

# 气泡排序

一般气泡排序所执行的次数总是一个三角形, 可见有很多时候并不需要再排序了, 所以使用前面介绍过的逆序对来作为是否继续排序的依据,可以节省一定时间

> 再改进

如果我们知道最后一个逆序对在那个位置, 那么我们就知道那个位置之后的部分实际上已经有序, 之后的排序不会再理会这部分了, 以此缩短遍历的数量,这样大部分情况下效率便缩减为`O(n)`

> 实际上气泡排序本来就会使最后的部分有序,所以总使优的.不会更差,但最坏时,还是`O(n²)`

*排序的稳定性*

一般期望,在被排序项相等的情况下,位置传入进来的相对顺序. 如下

```C#
//排序前
7A,2,3,7B,1,5,7C
//排序后
1,2,3,5,7A,7B,7C
```

如果他们的相对顺序变化了,称其为不稳定算法.  
不过对于气泡算法中,他是稳定的,交换条件是一项必须大于另一项,且每次只交换相邻的单位,所以总是稳定的

# 归并排序

首先将整个向量分解,之后两两合并,每次合并都是其有序,最后的到一个完全有序的向量.  

重点就是合并, 将两个队的第一个元素比较,较小的放入新的堆中,之后继续比较第一个,直到一个堆完全为空,此时将另一堆不比较,整个放入结果中.

> 这个过程实际只需要传入内存A,开辟内存B=A/2. 之后的C只需取自A的另一半,而不必分配内存, 这样做是安全的,因为A上的指针i不可能越过C上的指针k.

当待归并子序列长度不相等时候,看情况是否需要分配C的空间

> 这个效率是`O(nlogn)`

# 列表

从向量到列表, 就是从连续的物理地址变为非连续的物理地址,列表的逻辑上是连续的, 但对应的物理寄存器则不一定.

> 此时,查找第i号元素的效率就与i是第几号元素相关  
> 链表就是列表的一种体现形式

链表基础就不重复了,网上到处都是

# 选择排序

每次选择列表中最大的元素,将他移动到最后

> 经常使用的`[)`左闭右开区间又登场了

> 对于某种极低概率出现的时间而进行每次都进入的`if`判断.这不一定是一种优化,可能使效率更差

在选择最大元素时`>`和`>=`比较的区别是, 期望选择第一个,还是最后一个.  
由于每次要筛选剩余的全部数据中的最大值,所以效率为`O(n²)`

# 插入排序

每次选择任意一个元素,将其插入到要排序的列表中的合适位置.是列表仍然有序

> 每次插入都要遍历,所以效率为`O(n²)`  
> 而且其最好情况的发生概率极低,效率基本都是`O(n²)`  

这种算法就是输入敏感性算法,即其效率严格依赖于输入的内容,这里依赖于输入列表的逆序对数量,越无需,需要的时间越长

# 栈

与一般序列不同, 只能访问一种一端的第一个元素

> 进制转化

现又十进制数89,将其转化为二进制

每次过程实际上是将余2的结果作为二进制结果,而将除2的结果作为下次的起始点,直到最终为0

例子: `89%2 = 1`,	`89/2 = 44`
89	1  
44	0  
22	0  
11	1  
5	1  
2	0  
1	1  
0

倒过来最终结果就是`1011001`

所以这里存储结果可以用栈,后进先出自然得出结果

> 详细的检测括号和中缀表达式,逆波兰表达式,可见另一篇`栈`

特别的,栈也可以用于左混洗操作, 即`n次Push+m次Pop`循环往复,即可得到一组混洗过的数据

> 习题, 一个序列x1,x2,...,xn 能否被混洗为p1,p2,...,pn

# 队列

从后方进入,自前方退出  
也就是先进先出

不难看出,栈和队列实际上都是线性序列的特例,但他们在算法中经常扮演十分重要的角色.

# 树

它是由n（n>=1）个有限结点组成一个具有层次关系的集合

是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合

**术语**

* 节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推
* 节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度
* 树的深度：一棵树中节点的最大深度就是树的深度，也称为高度
父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点
* 子节点：一个节点含有的子树的根节点称为该节点的子节点
节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
* 兄弟节点：拥有共同父节点的节点互称为兄弟节点
度：节点的子树数目就是节点的度
* 叶子节点：度为零的节点就是叶子节点
* 祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）
* 后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）
* 森林：m颗互不相交的树构成的集合就是森林

在`兄弟节点`之间也定义了明确顺序的树,称为顺序树.

* 长度
  * 有些地方定义为联通的节点数, 有些地方定义为边数
  * 这里我们取边数

对于树, 每个点都有连通路径, 且不包含任何环  
即`无环连通图`

# 工具

```
O(1)
O(Logn)
O(n)
O(n²)
`2的N次方`
```

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
