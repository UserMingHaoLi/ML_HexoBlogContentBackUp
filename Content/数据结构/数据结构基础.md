---
title: 数据结构基础
date: 2021-09-02 01:04:00
updated: 2021-09-02 01:04:00
id: ml-20210902-010400-g157
categories:
	- 数据结构
tags: 
	- 数据结构
---

数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率

# 定义

数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的逻辑结构和数据的物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构

数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构

数据结构的研究内容是构造复杂软件系统的基础，它的核心技术是分解与抽象。通过分解可以划分出数据的3个层次；再通过抽象，舍弃数据元素的具体内容，就得到逻辑结构。类似地，通过分解将处理要求划分成各种功能，再通过抽象舍弃实现细节，就得到运算的定义

上述两个方面的结合可以将问题变换为数据结构。这是一个从具体（即具体问题）到抽象（即数据结构）的过程。然后，通过增加对实现细节的考虑进一步得到存储结构和实现运算，从而完成设计任务。这是一个从抽象（即数据结构）到具体（即具体实现）的过程

> 数据结构可以抽象的解决一类问题,是实现算法的基础  
> 数据结构和算法, 让我们回归计算本质, 计算机只是工具

<!--more-->

逻辑关系是指数据元素之间的前后间关系

1. 集合
2. 线性
3. 树
4. 图
5. ...

指数据的逻辑结构在计算机存储空间的存放形式

1. 顺序
2. 链接
3. 索引
4. 散列

# 常用的数据结构

* 数组(Array)
* 栈( Stack)
* 队列(Queue)
* 链表( Linked List)
* 树( Tree)
* 图(Graph)
* 堆(Heap)
* 散列表(Hash)

# 常用算法

* 检索
* 插入
* 删除
* 更新
* 排序

# 绳索计算机

计算机只是计算的工具  

取12段等长的绳索,首尾链接成环状.  
从任意节点A出发,走4节为B点,再取另一方向3节为C点.  
从ABC三点拉直绳索,便可得到一个直角`∠A`  

此时,绳索就是计算机, 任何情况都能得到直角的技巧就是算法.  

> 勾股定理

# 尺规计算器

输入任意线段, 输出他的两个点,使其可以三等分 

从A出发任意方向一条不与AB重合的射线p  
取p上三个点D1,C1,B1, 使 AD1 = D1C1 = C1B1

链接``` BB1 ```  
经过D1 做 BB1 的平行线, 交AB与D
经过C1 做 BB1 的平行线, 交AB与C

此时可得DC两点即为三等分点.

> 子程序: 过直线外一点,做平行线  
> 算法之间有包含关系

# 什么是计算

计算 = 信息处理

即: 借助某种工具,准寻一定规则,以明确而机械的方式运转进行.并给出结果

所以算法是指:给定计算模型情况下,解决特定问题的指令序列  
包含`输入`,`输出`.  
满足`正确性`,`确定性`,`可行性`.`又穷性`.

> 当然,还有很多额外定义,不过了解以上这些就足够了

## 又穷性

对于一个冰雹算法(n/2 | 3+1). 我们不能得知他是否又穷.  
因为他需要满足所有的`n`. 

> 扩展:死循环或栈溢出

# 什么是一个好算法

* 简单
* 大规模
* 一般或异常
* 可退化
* 能处理任何输入
* 健壮
* 可读

> 但这些都不是最重要的  

我们需要追求的是**效率**  
即:速度尽可能快,存储空间尽可能小  

> 很多时候,我们需要在速度或者空间中的一方做出让步,换取另一方的提升.

# 度量效率(性能测度)

> 了解这个世界最好的方式就是测量他(的某一方面).  
> 如果你需要改进某样东西,你就要取测量他

所以,对于算法,我们需要计算他的成本(时间成本, 空间成本)  
然后得出度量规则, 并进行比较

使用算法A求解实例P,记作Ta(P)  
但这个定义意义不大, 因为实例可能以偏概全,毕竟可能的实例太多了

# 问题规模

成本,大部分情况下都与规模呈正相关

零Ta(n) = 用特定算法A求解某一类问题规模为n的实例, 所需计算成本

讨论特定算法A时, 记作T(n)

> 但是, 即使是同一问题,且等规模,任然有太多其他因素影响效率

比如求解一个问题时有可能直接求出一个不可能更优的值, 所以并不能代表效率

> 所以我们对于算法,只关注最坏(成本最高)情况, 即最后一个才能找到  

取 T(n) = max{ T(P) | |P| = n}

# 理想模型

如果只进行实验,则不够全面.  

* 规模
* 类型
* 程序员,语言,编译器
* 选项,结构,系统

*所以我们需要抽象出一种理想的平台.或者模型*

# 图灵机

略

> 我们可以将图灵机作为这种理想平台,用于评判效率

# 大O记号

我们关心足够打的问题,且更关心他的增长趋势  
即:问题规模变大,成本如何提升

最终我们得到一条曲线.

这就得到了我们需要的增长率

> 忽略常系数  
> 忽略低次项  
> 因为他们再增长的过程中,不占据主要地位,且越往后占比越小

## O(1)

不含有循环,分支,递归

> 实际上可以含有,但必须是极少量且增幅极少可被忽略的.

## O(Logn)

因为常数可以忽略, 所以Log100N可简化为LogN.同理所有常数都被忽略

## O(n²)

此处的2可替换为任意数x. 总是取多项式中最大的项,理由同上

> 难解:颠倒以下为 2的N次方. 此时增长太快,被认为不可容忍 ,也叫指数复杂度  
> 此类算法一般认为是无效算法的起点 

> 很多算法的`2的N次方`解很同意的出,但想要优化为`O(n²)`则非常难,甚至是无解

## 难解举例

美国大选共计51个投票区共计538票,是否可能存在一个投票方法使两个候选人得票相同(每人269票)

> 典型的两个子集划分问题,这是一个`NP-Complete`问题.即目前计算模型而言最少也是难解级别

# 复杂度计算

## 级数

即典型的`1+2+...+n` = `n(n+1)/2`,此为`O(n²)`. 对于末尾n本来就是多次方的情况,也可以用此式子表示

`几何级数`则取末尾即可, 因为较小的次方可以忽略  
`1+2+4+...+2的N次方` = `O(2的N次方)`

`收敛级数` = `O(1)`  
`1/1 + 1/2 + ... + 1/n`

`调和级数` = `O(Logn)`  
和`收敛级数`类似,但不收敛,只是长度有限

`对数级数` = `O(nLogn)` 
`log1 + log2 + .. +logn`

## 循环

两个典型

```
for(i=0;i<n;i++)
for(j=0;j<n;j++)
	Op();
```

```
for(i=0;i<n;i++)
for(j=0;j<i;j++)
	Op();
```

直觉看上去应该下面的小些,实际他们都是`O(n²)`  

我们可以吧i和j作为横纵轴,前者是一个矩形,后者是一个三角形.但他们都是`O(n²)` 增长

> 一旦循环中的一项从`i++`调整为`i = i²`则复杂度简化为`O(n)` 

## 冒泡排序

> 排序我们一般成为升序或者降序,实际上默认算法一般是升序的,学名应该叫`非降`排序,因为容忍相等

同上面循环的案例,冒泡排序是`O(n²)`

问:冒泡排序是否可以终止且给出正确结果.
答:可以,如下证明

* 不变性:经过K轮扫描交换后,最大的K个元素必然就位
  * 因为每次扫描必然将一个最大的元素移动至末尾
* 单调性:经过K轮扫描后,问题规模缩减到n-k
  * 因为每次扫描都是末尾K个元素为有序,且不再参与和影响后续算法
* 正确性:经过至多n轮扫描后,必然终止且给出正确结果
  * 结合上两个推到而出

> 算法是思路,具体编码的Bug暂不考虑

## 封底估算

由于精度可以忽略级数较低的部分,所以估算一下也能得出准确的结论

在两个城市各打一口井,在一个城市阳光正射时记录另一个城市的阴影偏转角度(由于太阳距离过远,阳光近似为平行过来的)  
通过角度/360得出两城市距离和地球周长的比值,便可求出地球周长,这样测量实际也上不会比现代科技工具差上一个数量级.实际当时计算结果为`39350`,现在结果为`40076`差别小于2%;

> 所以我们很多时候可以估算

### 例子

一天 = `24 * 60 *60` 即 `24*3600`

我们将其近似为`25*4000`,则为`10的5次方秒`

一世纪 = 100年 = 365*100, 近似为`3*10的4次方`天, 根据上面的天/秒结果  
得出一世纪 = `3*10的9次方`秒

则三生三世 = 300年 近似为`10的10次方`秒

宇宙大爆炸至今≈`10的21次方`秒

> 实际1天=86400秒,一年(365天)=3153600秒,一百年=315360000,三百年=946080000秒  
> 可以看到误差还可以

> 然后可以简化记忆, 在三生三世中的一天,可以看作一天中的一秒(`10的10次方`中的`10的5次方`,也就是5个数量级,刚好`10的5次方`也是5个数量级)
> 宇宙大爆炸中的三生三世,可以看作三生三世中的0.1秒(`10的21次方`中的`10的10次方`也就是11个数量级,`10的10次方`是10个数量级,换算为0.1)

## 递归和迭代

初学时我们认为递归优于迭代,但算法层面迭代效率往往更好

## 分治

求和计算

`1+2+...+n`

很明显是`O(n)`

> 对于空间复杂度,我们一般只计算处输入外,因为算法额外添加的部分  
> 此处为`O(2)`(计数器i和结果Sum),也就是`O(1)`

### 减而治之

对于一个问题,将其分解为一个更小规模的子问题,和一个可以求解的平凡问题, 而小问题的本质与之前的大问题相同,所以也可以如此分下去. 最终可以得出解.

> 此时递归效率是`O(n)`,也叫线性递归  
> 推算过程如下`T(n) = T(n-1) + O(1)`,且`T(0)=O(1)`. 所以有n+1个`O(1)`,得出`O(n)`

### 二分递归

我们将每个问题分为两个一样大的问题(由于奇数,可能其中一个稍大1)

> 此时问题变为以2为倍数的几何级数

问题变为`2的0次方+2的1次方+...+2的logn次方`, 最后结果`O(n)`

更快速的求解方式如下  
问题实际上是从`T(n)`分解为`2 * T(n/2)`.最终分下去还是`O(n)`

> 一般,对于下界限lo和上界限hi,我们有[lo,hi), 即包含lo但不包含hi(只包含hi-1)  
> 这样我们思考更简便些

#### Max2问题

对于一个数列中寻找最大的两个值

最坏的方法是比较两次, 需要O(2n-3)  
然后是维护两个指针来只比较一次, 需要O(n-1)  
最后可以分治,为O(5n/3-2)

> 注意,此时二分的最小单位为3个(因为是求Max2,且三个不能分成两个Max2). 而且只需要4个结果中的三个参与比较(败者组的第二位直接不比较)

> 最后都是O(n), 没啥意思.  
> 后面还有更多算法可以提升效率,现在暂且不讲,关键字`锦标赛树`

# 做一个算法分为三步

1. 先让他工作
2. 让他正确工作
3. 提升效率

> 为了效率,舍弃递归选择迭代

对于一个式子`T(n) = T(n-1) + T(n-2) + 1, n>1`, 其中边界`T(0) = T(1) = 1`

> 这是一个斐波那契数列

不难看出,其效率为`2的N次方`, 实际效率其实是`(1+√5) / 2`约等于`1.61803的N次方`

指数的效率是非常慢的,主要原因在于其递归中有太多重复计算.  
所以只要记住结果以备查询,效率会好很多,这将使计算过的内容时间变为`O(1)`  
	* 而且只用记录最近两个即可.
然后再改为迭代算法, 从低到高逐步运算.

```C#
int f = 0;
int g = 1;
while(0 < n--)//n是迭代次数
{
	g = g + f;//等同于斐波那契+1
	f = g - f;//实际上就是计算前的g
	//也就是g和f都在斐波那契数列上+1
}
return g;
```

上面代码时间复杂度`O(n)`,空间复杂度`O(1)`

## 求公共子序列

现有两个字符串,要求求出其中公共子序列的长度  
一个字符串S，去掉零个或者多个元素所剩下的子串称为S的子序列。最长公共子序列就是寻找两个给定序列的子序列，该子序列在两个序列中以相同的顺序出现，但是不必要是连续的

```C#
//参数
string strRow = "ALGORITHMS";//参数1 作为每行第一个
string strCol = "ALCHEMIST";//参数2 作为每列第一个

//初始化,列和行各有一个空白位置(不用空白位置就多加条件判断,这里加空白看的清楚点)
int nTblRow = strRow.Length + 1;
int nTblCol = strCol.Length + 1;
int[,] resultTbl = new int[nTblRow, nTblCol];
//开头的空白行和空白列,计数器默认为0
for (int i = 0; i < nTblRow; i++)//可以使用`resultTbl.GetLength(0)`获取多为数组的相应Length
{
	resultTbl[i,0] = 0;
}
for (int i = 0; i < nTblCol; i++)
{
	resultTbl[0, i] = 0;
}

//计算, 从1开始,空白行和空白列不再计算
for (int i = 1; i < nTblRow; i++)
{
	for (int j = 1; j < nTblCol; j++)
	{
		char cRow = strRow[i - 1];//这里使用的是传入参数,没有空白,所以减去Tbl中空白的一个
		char cCol = strCol[j - 1];

		bool bEquals = cRow == cCol;//是否相等
		if (bEquals)
		{
			//取对角+1
			int nLeftTop = resultTbl[i-1, j-1];
			resultTbl[i, j] = nLeftTop + 1;
		}
		else
		{
			//取左或上的最大值
			int nLeft = resultTbl[i, j - 1];//左边其实就是列-1
			int nTop = resultTbl[i - 1, j];//上边就是行-1
			int nMax = Math.Max(nLeft, nTop);
			resultTbl[i, j] = nMax;
		}
	}
}

//输出,打印表格
int nPrintRow = nTblRow + 1;//打印还需要显示额外输入参数,所以再+1
int nPrintCol = nTblCol + 1;
char strSpace = ' ';//多语言?
for (int i = 0; i < nPrintRow; i++)
{
	for (int j = 0; j < nPrintCol; j++)
	{
		if (i == 0)
		{
			if(j - 2 < 0)
			{//前两个为空格
				Console.Write(strSpace);
			}
			else
			{//实际输入参数
				Console.Write(strCol[j - 2]);//当行为0时,逐步展示每列的第0个
			}
		}
		else if (j == 0)
		{
			if (i - 2 < 0)
			{
				Console.Write(strSpace);
			}
			else
			{
				Console.Write(strRow[i - 2]);
			}
		}
		else
		{
			Console.Write(resultTbl[i - 1, j - 1]);//非参数展示,输出结果
		}
	}
	Console.Write(Environment.NewLine);//当前环境的通用换行
}

Console.ReadLine();
```

输出结果如下

```C#
  ALCHEMIST
 0000000000
A0111111111
L0122222222
G0122222222
O0122222222
R0122222222
I0122222333
T0122222334
H0122333334
M0122334444
S0122334455
```

最终结果就是右下角的数字`5`;

> 最后,由于有结果集,所以是可回溯的.  
> 如有需求,可以输出所有子序列结果

# 动态规划

动态规划（Dynamic Programming）是一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。

基本思想：将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）  
与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次  
如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。通常可以用一个表来记录所有已解的子问题的答案  
不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路

采用动态规划求解的问题需要具有两个特性：

* 最优子结构（Optimal Substructure）：问题的一个最优解中所包含的子问题的解也是最优的。

* 重叠子问题（Overlapping Subproblems）：用递归算法对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。

动态规划的关键是 —— 记忆，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。

# 接口与实现

抽象数据结构,指模型上的一组操作  
数据结构,指基于某种语言,实现的一整套算法.

> 所以将操作抽象为接口

相邻逆序对数量,可以用于度量逆序程度

# 向量

向量是一组定义好的抽象数据结构, 最终被各种代码实现为可变长的数组.  
C#中是ArrayList,或者说IList

> 为什么采用容量加备策略  
> 对于一个Max的插入,递增效率达到O(n). 倍增则是O(1)  
> 这个效率是通过牺牲50%空间换来的.

# 平均复杂度

根据概率分布,将成本加权.   
割裂了操作的连贯性和关联性

# 分摊复杂度

对连续的数据结构实施多次操作, 所需的总成本  
实际角度考虑.  
更精准的判断真实性能

> 算法,数据结构的课程中,经常不对输入做判断或异常处理,这是为了教学方便,但实际运用时,这些是必须的.

# 有序

将数据变为有序后,相关算法的效率可以得到优化.

比如删除重复, 现在只需要一遍`O(n)`   
还有二分查找

> 一般的插入,删除等基本步骤,都要求有返回值,以便更好的参与其他算法,作为其组成部分  
> 否则,将成为孤立功能

```C#
V.Insert(1+V.Search(e), e);//同样的数据放在一起
```
*上述代码要求查找到`不大于e的元素的位置`*  

> 使用小于号`<`更可读, 可理解为从左到右,从小到大.

但是此算法向左侧比较一次, 而右侧为第二次,总体而言,需要O(1.5*Logn)

想要再次优化, 我们需要将左边更深,右边更浅,于是性能还能优化

这就是**斐波那契数列**, 左边的个数`fib(k-1)` 总是大于 `fib(k-2)`.

实际上就是精妙的取了一个中间值,二分法总是取`0.5`为中点,而fib则是`0.6180339...`, 此时常系数从`1.5`降低至`1.44042`左右

还有更好的一个办法, 即每次只判断一次, 所以左和右都只要一次即可深入一层. 但这样导致没法判断`==`,则每次都会使规模为1之后才能确认结果

后续在需要更优的算法,则需要容器内更详细的排列规则(方便推算更好的切分中点,甚至每次动态计算中点)  
但可能收到干扰和蒙骗, 推荐综合使用,如下  
* 大规模: 插值查找
* 中规模: 折半查找
* 小规模: 顺序查找

这样能确保精度,防止干扰,还可以有效提升效率

# 气泡排序

一般气泡排序所执行的次数总是一个三角形, 可见有很多时候并不需要再排序了, 所以使用前面介绍过的逆序对来作为是否继续排序的依据,可以节省一定时间

> 再改进

如果我们知道最后一个逆序对在那个位置, 那么我们就知道那个位置之后的部分实际上已经有序, 之后的排序不会再理会这部分了, 以此缩短遍历的数量,这样大部分情况下效率便缩减为`O(n)`

> 实际上气泡排序本来就会使最后的部分有序,所以总使优的.不会更差,但最坏时,还是`O(n²)`

*排序的稳定性*

一般期望,在被排序项相等的情况下,位置传入进来的相对顺序. 如下

```C#
//排序前
7A,2,3,7B,1,5,7C
//排序后
1,2,3,5,7A,7B,7C
```

如果他们的相对顺序变化了,称其为不稳定算法.  
不过对于气泡算法中,他是稳定的,交换条件是一项必须大于另一项,且每次只交换相邻的单位,所以总是稳定的

# 归并排序

首先将整个向量分解,之后两两合并,每次合并都是其有序,最后的到一个完全有序的向量.  

重点就是合并, 将两个队的第一个元素比较,较小的放入新的堆中,之后继续比较第一个,直到一个堆完全为空,此时将另一堆不比较,整个放入结果中.

> 这个过程实际只需要传入内存A,开辟内存B=A/2. 之后的C只需取自A的另一半,而不必分配内存, 这样做是安全的,因为A上的指针i不可能越过C上的指针k.

当待归并子序列长度不相等时候,看情况是否需要分配C的空间

> 这个效率是`O(nlogn)`

# 列表

从向量到列表, 就是从连续的物理地址变为非连续的物理地址,列表的逻辑上是连续的, 但对应的物理寄存器则不一定.

> 此时,查找第i号元素的效率就与i是第几号元素相关  
> 链表就是列表的一种体现形式

链表基础就不重复了,网上到处都是

# 选择排序

每次选择列表中最大的元素,将他移动到最后

> 经常使用的`[)`左闭右开区间又登场了

> 对于某种极低概率出现的时间而进行每次都进入的`if`判断.这不一定是一种优化,可能使效率更差

在选择最大元素时`>`和`>=`比较的区别是, 期望选择第一个,还是最后一个.  
由于每次要筛选剩余的全部数据中的最大值,所以效率为`O(n²)`

# 插入排序

每次选择任意一个元素,将其插入到要排序的列表中的合适位置.是列表仍然有序

> 每次插入都要遍历,所以效率为`O(n²)`  
> 而且其最好情况的发生概率极低,效率基本都是`O(n²)`  

这种算法就是输入敏感性算法,即其效率严格依赖于输入的内容,这里依赖于输入列表的逆序对数量,越无需,需要的时间越长

# 栈

与一般序列不同, 只能访问一种一端的第一个元素

> 进制转化

现又十进制数89,将其转化为二进制

每次过程实际上是将余2的结果作为二进制结果,而将除2的结果作为下次的起始点,直到最终为0

例子: `89%2 = 1`,	`89/2 = 44`
89	1  
44	0  
22	0  
11	1  
5	1  
2	0  
1	1  
0

倒过来最终结果就是`1011001`

所以这里存储结果可以用栈,后进先出自然得出结果

> 详细的检测括号和中缀表达式,逆波兰表达式,可见另一篇`栈`

特别的,栈也可以用于左混洗操作, 即`n次Push+m次Pop`循环往复,即可得到一组混洗过的数据

> 习题, 一个序列x1,x2,...,xn 能否被混洗为p1,p2,...,pn

# 队列

从后方进入,自前方退出  
也就是先进先出

不难看出,栈和队列实际上都是线性序列的特例,但他们在算法中经常扮演十分重要的角色.

# 树

它是由n（n>=1）个有限结点组成一个具有层次关系的集合

是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合

**术语**

* 节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推
* 节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度
* 树的深度：一棵树中节点的最大深度就是树的深度，也称为高度
父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点
* 子节点：一个节点含有的子树的根节点称为该节点的子节点
节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推
* 兄弟节点：拥有共同父节点的节点互称为兄弟节点
度：节点的子树数目就是节点的度
* 叶子节点：度为零的节点就是叶子节点
* 祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）
* 后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）
* 森林：m颗互不相交的树构成的集合就是森林

在`兄弟节点`之间也定义了明确顺序的树,称为顺序树.

* 长度
  * 有些地方定义为联通的节点数, 有些地方定义为边数
  * 这里我们取边数

对于树, 每个点都有连通路径, 且不包含任何环  
即`无环连通图`

为了使查找更效率, 存储更少, 我们只保存每个节点的父节点,长子,下个兄弟节点. 这使得查找变为`O(1)`

# 二叉树

每个节点的度数不超过2, 即每个节点不超过两个孩子.  
这样,就可以区分出左子节点和右子节点.

**凡是有根且有序的树,都能被描述为一颗二叉树**  

也就是使用上面描述过的长子,兄弟法, 使其子节点为长子,下一个兄弟,即可转为为二叉树.

## 满二叉树

国内一般指`一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树`  
国际一般定义`如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树`  

## 完全二叉树

树中的结点按从上至下、从左到右的顺序进行编号  
编号为`i`的结点与 满二叉树 中编号为`i`的结点在二叉树中的位置相同

可得,满二叉树是完全二叉树, 完全二叉树不一定是满二叉树.  

*一个二叉树节点*
```C#
struct BinNode
{
	BinNodePos parent, lchild, rchild;//父亲,左右孩子
	T data;
	int hright;//高度
	int size();//子树规模
	BinBodePos insertAsLC(T);//作为左孩子插入
	BinBodePos insertAsRC(T);//作为右孩子插入
	BinBodePos succ(T);//(中序遍历意义下)当前节点直接后记
	//各种遍历
	//子树层次遍历
	//子树先序遍历
	//子树中序遍历
	//子树后续遍历
}
```

*二叉树*
```C#
class BNinTree
{
	int _size;
	BinNodePos _root;
	virtual int updateHeight(BinNodePos x);//更新节点x的高度
	int updateHeight(BinNodePos x);//更新x及祖先高度
	int size(){return _size;}
	bool empty(){return !root;}
	BinNodePos root(){return _root;}
	//其他子树遍历,删除,分离,插入等..
}
```

对于只有一个节点的树,其高度为0. 若无任何节点, 其高度为-1  
其他时候,节点的高度等于其孩子中的最大高度+1

要遍历树的节点, 必然现有一个固定顺序,不然每次遍历比一样的单位,则无意义.  

*先序遍历*  
先选择任何一颗子树,先选中其根节点,并递归的遍历其左子树,然后遍历其右子树

*中序遍历*  
择任何一颗子树, 先遍历其左子树,然后是根阶段,最后是右子树

*后序遍历*
和先序遍历一样, 只是变为中右左

> 这里就可以使用栈, 先压入右子树,然后压入左子树,下次就可以取出左子树,之后重复压栈,形成类似递归的效果  
> 这样性能比直接递归好一点

我们可以看到,每次访问,肯定是一条左侧链, 一条链结束后,马上开始另一条链

所以修改算法, 不在将左孩子入栈,而是只将右孩子入栈,并使当前节点赋值为左孩子,如此继续迭代,性能又稍好些.

*中序遍历也可以递归如下代码*
```C#
void traverse(BinNodePos x, Delegate dg)
{
	if(!x) return;
	traverse(x.lChild, dg);
	dg(x.data);
	traverse(x.rChild, dg);
}
```
*迭代形式如下*
```C#
void traverse(BinNodePos x,Delegate dg)
{
	Stack x;
	goAlongLeftBranch(x, S);//X的所有左子树入栈
	if(S.empty()) break;
	x = S.Pop();//左子树倒序出栈
	dg(x.data);//回调
	x = x.rChild;//下个右子树
	//注意: 下次循环又会重新将倒序出栈的x的所有左子树入栈, 所以可与完全递归整个树
}
void goAlongLeftBranch(BinNodePos x, Stack S)
{//将此节点不断深入左侧,并入栈
	while(x)
	{
		S.push(x);
		x = x.lChild;
	}
}
```
可与看到`traverse`和`goAlongLeftBranch`看似使`O(n²)`,实际深究却发现,他们最多与节点数量相等,也就是`O(n)`   
迭代和递归都是`O(n)`,但迭代减少了常系数部分,所以效率更好

> 这里使用了分摊分析

*层次遍历*  

此时便可以引入队列, 只需将根节点入队,并依次将所有队列中的节点的左右孩子入队,即可实现顺序性的层次遍历.

如何通过遍历结果还原一棵树呢.  
需要`先序`或`后续`+中序.至少需要两种互相印证,才能直到一个节点到底是左是右.  
因为其中可能有空节点,或者说空树.  
但是,当二叉树为`真二叉树`时,就可只通过`先序`或`后续`来还原.  
因为其中不存在空树.


# 图

在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。  
在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关  
*图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关*

图是由顶点的有穷非空集合`V(G)`和顶点之间边的集合`E(G)` E(G)E(G)组成，通常表示为: G = ( V , E ) G=(V,E)G=(V,E)

> 一般数据结构中的图不讨论`自环`  
> 且由于有向图可与表示无向图和混合图, 所以一般讨论的都是有向图.


一个图G若满足:  
1. 不存在重复边
2. 不存在顶点到自身的边

则称图G为`简单图`

如果一条通路中不含重复节点,则为`简单路径`  
否则为`普通路径`

如果路径的起点和终点重合,则称为`环路`, 环路也有简单和不简单之分.

这里就引出了`有向无环图`

经过所有的边一次,且只有一次的环路为`欧拉环路`  
经过所有点一次,且只有一次的环路为`哈密顿环路`

**如何表示一个图结构**

*邻接矩阵*

一个二维数组,一维和二维的长度都是节点数.  
期内记录了任意两个节点之间的关系.  

*关联矩阵*

一个二维数组,使用节点数和边数共同组建  
如果节点n与边e关联,则将期内设置为权重值.

> 一般,我们使用`邻接矩阵`较多

```C#
enum VStatus
{
	UnDisCovered,//未发现
	DisCovered,//发现
	Visited,//访问
}
class Vertex
{
	T Data//数据
	int inDegree;//入度
	int outDegree;//出度
	VStatus status;//状态
	int dTime;//发现时刻
	int fTime;//访问完毕时刻
	int parent//遍历树中的父节点
	int priority;//遍历树中的优先级
}
enum EStatus
{
	UnDetermined,//不确定
	Tree,//树
	Cross,//渡
	Forward,//前
	Backward,//后
}
class Edge
{
	T data;//数据
	int weight;//权重
	EStatus status;
}
```

然后就添加一些操作, 比如经典的`Get`,`Set`  
获取点的邻居,获取首个点,判断边是否存在,插入边,删除边

插入顶点就麻烦些了, 需要扩展顶点和边的容器,并将每条边扩充一位.  
删除也就是插入的逆过程

`邻接矩阵`便于理解,适用范围广,尤其适合稠密图,  
很多操作, 包括判断两点之间是否有边等..都是只要`O(1)`

缺点: 需要`n²`的空间,而且有很多浪费,利用率大概只有`1/n`

> 如果有办法进行遍历,就可以将任何结构转化为线性.

选取一个起点,访问它的周围连接点,并递归的访问这些点不重复的相邻点.直到所有点都接受了访问  
这个过程中,只选择我们得到的那条边,就得到一个无环图,也就是一棵树.

这就是`广度优先遍历`,也是树的层次遍历.  

完成了图到树的转化,之后就可以转化为二叉树,在遍历为线性结构   
*这也是之前状态里面有`Tree,//树`的原因*  
*可使用一个队列来管理接触到的点*  

为覆盖所有联通域,将每个点作为起点进行尝试,一旦这个点`未发现`则做一次转化操作,如此,便可遍历所有连通域. 

然后是`深度优先搜索`  
选择顶点s, 若s有`尚未被访问的`邻居,则任选其一,没有则返回,递归执行

边的一个状态`Forward,//前`就是用于描述祖先指向其后代的非`Tree`边.  
同样的`Backward`就是后代指向祖先, 且只要出现`Backward`就代表出现了一条回路.

*当然,还需要处理其他`连通域`*  

> 深度优先搜索最重要的部分就是标记了两个时间标签,后续很多算法都能用它做出巨大优化.  

这将可与直接使用这两个时间标签来判断是否有血缘关系.  
无需使用树的追溯到根节点的算法.只需`O(1)`即可

# 二叉搜索树

二叉搜索树  `Binary Search Tree` (BST)

每个Item都拥有一个词条,内存储有关键码和数值, 这个关键码可与互相比较,用于快速判断  

每个节点的左子树都不大于该节点,右子树都不小于该节点, 且所有节点(词条)不得重复, 于是就有了顺序性.  
这导致对于`BST`的中序遍历,必然单调非降序

> 实际上可与重复(但不推荐重复),但需要额外处理,目前暂不引入

其代码大部分都从二叉树继承而来,只是对于查找,插入,删除有一些变化, 且新增一些方法,如旋转,等...

对于查找, 传入值与当前子树根节点比较,可与看到,每次我们都可以排除一颗子树,这就是经典的二分查找  
查找需要返回查找到的节点(可能为Null), 并返回其父亲. 如此方便外界操作

插入实际上就是一次查找,并将值放置到查找失败的点. 这就是为什么查找需要返回父节点的原因,方便后续操作.  
删除也类似, 但是要注意将要删除节点的子树接上一个新父节点.  

如果只有一个子树,直接将父节点设为原来的祖父即可, 但是如果有两个,且祖父原来有也有两个,那么我们不能全都设为祖父的子树(毕竟这是二叉树)  

这个时候,我们找到待删除元素位于中序遍历的直接后继,调换她两再树中的位置, 就简化为了第一种情况, 因为这个直接后继是没有左孩子的(思考一下,确实如此)...

虽然此时BST的各种算法都只有`O(h)`,即等同意高度的复杂度,但我们仍然不满意, 原因在于,`没有办法有效控制其高度的规模`, 这导致BST完全可以是一条单项链表(每个节点只有一个子树). 如此效率实际上就退化为`O(n)`,即节点数量的复杂度  

最重要的是,依据随机生成的结果看, 退化为线性结构的几率还是很高的, 平均高度为`O(√n)`  

中序遍历实际上有歧义性, 两个有所不同的树,其中序遍历可能一样. 这表明每个节点在上下层次上有很大的自由度.  

我们想办法约束这个自由度,就有了`AVL树(平衡二叉搜索树)`, 其高度满足`O(Logn)`, 但代价是每次破坏其平衡,需要最多`O(Logn)`的效率来使其重新保持平衡, 也就会新增很多重平衡`reBalance`的相关算法

直接从BST派生出AVL类, 重写其插入和删除  

首选推算插入之后可能失衡的节点, 我们看到,其所有的祖先都有可能受影响失衡  
而删除,则至多一个祖先失衡.

> 平衡的关键就是任何左子树和右子树的高度差不超过1

但是当高度复原之后,其所有祖先的平衡因子也将复原,所以插入相对是好解决的.

复原操作,也就是旋转操作.  

从插入点向父亲查找,一直到根, 找到任何不平衡的节点,则开始旋转  
旋转需要三个参数,不平衡的节点g,其子节点p,其孙子节点v, 这些节点都是向上查找的时候路过的.  
*顺便说一下,这个命名是按照,祖父,父亲,节点的顺序命名的.*

此时使用单旋,即将这颗以g为根的子树,变化为以p为根. 依据p所在左右不同,又区分为左旋或右旋  
本例使用左旋,当p和v都是右子树的情况下适用  
引入一个虚拟节点rc指向p, 将g与p断开连接,此时g的将p的不含v的子树变化为g的p方向子树.  
在本例中为,将p的左子树变化g的右子树, 此时g不在于p相连,下次操作需要用到我们引入的rc指针.  
此时p没有左孩子了, 将g作为p的左孩子, 此时p就拥有了左孩子g,和右孩子v.  
此时,将此子树的根由g替换为p. 完成单旋.

> 所有单旋的前提是pv在通往g路径的同侧,即三个节点同时向左或向右成一条线, 此时可以将p作为根,而g作为非v那一边的子,完成一次单旋.  

插入时失衡的高度回复平衡,整树也重新变为AVL树

*那么,gpv不在一条直线上如何处理呢*

这就需要旋转两次,第一次将其转化为一条直线上,第二次完成旋转.  

首先来看一个例子,根节点为g,其右节点为p,p的左节点为v,呈现一种Z字型.  
首先,以P为节点,进行一次右旋,按照之前的方式  
引入一个虚拟节点rc指向v,将p与v断开连接,由于要交换p和v的位置,使gpv成一条线,  
此时将v的右子树变化为p的左子树(原来v所在的位置).  
再将p作为v的右子树, 最后将g的右子树从p设置为v.  
此时变为第一种形式,即从根g出发,其右子树为v,v的右子树为p. 再只需进行一次左旋即可复原AVL树.

> 如何理解旋转这个概念,为什么要叫做左旋,右旋.  

我们将一个三层的二叉树看作三角形  
第一层一个位置,并只能是g  
第二层两个位置,其中一个是p  
第三层四个位置.且在p下方的两个位置中有一个是v

穷举出如下全部四种情况.

```C#
   g
 p   *
v * * *
//右旋
   g
 p   *
* v * *
//左旋后右旋
   g
 *   p
* * v *
//右旋后左旋
   g
 *   p
* * * v
//左旋
```

看完全部四种情况,再来说何为旋转  
只需想象要旋转的节点和其下的路径节点是有一根绳子链接的,必须相邻.  
如此便有两种情况,从g出发的gpv,从p出发的pv.   

如此,从选定的根节点出发,就只有一条路径,即从g出发,不能走p,就只能走另一条`*`路线,然后p和v相继跟上,就完成平衡  
如上四个例子中的第一个例子,这次引入一个虚构的暂存处来更好理解,小时的节点就是去暂存了  

```C#
//先给其他*节点命名
   g
 p   3
v 1 2 4
//g无法向p移动,则只能向右下移动
//断开gp的联系,分裂为两棵树
   g
     3
    2  4
   
 p   
v 1  
//此时g已占据之前1所在的位置(即根节点的右子树),而根节点则空出来
//p若想称为根节点,则必须舍弃右子树,刚好g还差了个左子树,于是p将1给与g作为左子树
   g
 1   3
    2  4
   
 p   
v    
//然后p称为根节点
   p
 v   g
    1 3
	 2 4
//这里看似高度差2,失衡了,实则不然,v下面其实还有一个新插入的值(也就是引起失衡的元凶)
   p
 v   g
0   1 3
	 2 4
//如此便是一次右旋
```

那么,以p为根旋转又如何呢, 看例子2

```C
   g
 p   4
1 v 3 5
//首选我们要将其变化为gpv一条直线的模式
//于是我们选择p为根节点,准备旋转,但是p无法向v移动,则只能向左下移动

 p v
1 
//此时根节点控制,v称为根节点
//当然,别忘了v下面其实还有一个新插入的值 
//如果此值为左子节点,则由于左子节点已经为p,原先的值交给p作为其右子节点
//如果此值为右子节点,则不受影响,随v一起移动.
    g
  v   4
 p 2 3 5
1  
    g
  v   4
 p   3 5
1 2
//此时就和例子1一样了,快进一下就完成了
   v
 p     g
1    2   4
        3 5
   v
 p     g
1 2      4
        3 5
```

> 为什么这样左就平衡了呢,因为插入的节点一定在v的子树中,所以v是导致失衡的元凶,即平衡差为2.  
> 将v抬升即可平衡(还要要照顾中序遍历的顺序),此时平衡差消除,中序遍历任然有顺序,则回复AVL树

> TODO 自己写点代码

# 工具

```
O(1)
O(Logn)
O(n)
O(n²)
`2的N次方`
```

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
