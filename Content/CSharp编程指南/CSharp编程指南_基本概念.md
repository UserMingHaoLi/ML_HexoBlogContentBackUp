---
title: CSharp编程指南_基本概念
date: 2021-04-08 23:54:00
updated: 2021-04-08 23:54:00
id: ml-20210408-235400-g116
categories:
	- 基础
	- CSharp编程指南
tags: 
	- 基础
	- CSharp编程指南
	- CSharp
---

# 引言

C#编程指南,内容来自 [Microsoft官方文档][csharpDoc_Link]

本系列为本人阅读后加工得出,实际内容不止指南篇,还会包含概念,参考等部分.基本等同于全文阅读并笔记.

<!--more-->

# 应用程序启动

每个应用程序都从`Main`方法进入  
但是`Main`方法并没有任何额外的元数据,所以编译器要求每个应用程序只能拥有一入口.  

*以下版本的`Main`都被视为入口*
```CSharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

> 如果你一定要定义多个`入口`,可以由编译器设置决定用哪个.

上述例子表明,`Main`可以接受`string[] args`,  
也可以返回`int`类型.

## 参数

该 `string[]` 参数包含在启动应用程序时指定的命令行参数.  
*详细点说就是从`cmd`启动时填写在后面的任何追加内容*

`string[]`参数决不会为 `null`,但如果未指定命令行参数,则其长度可能为零.

`入口`*不受访问性约束*,具体而言执行环境总是可以访问应用程序的入口点,无论其声明的可访问性如何.

应用程序入口点方法不能在泛型类声明中

## 返回值

用于`应用程序终止`

# 应用程序终止

如果应用程序的 `入口` 方法的返回类型为 `int`, 则返回的值将用作应用程序的 *终止状态代码*.  
此代码的目的是允许向执行环境进行成功或失败的通信.

如果返回值为`void`,则在运行完毕后默认返回状态代码`0`

在应用程序终止之前,将调用其所有尚未进行垃圾回收的对象的析构函数.  
除非已通过调用库方法明确终止, 例如`GC.SuppressFinalize`

# 声明

*声明,是程序员对编辑器的一种交代,这表明程序员知道自己在干什么*

字段声明和局部变量声明的顺序决定了其初始值设定的顺序

如果不声明枚举的值,则枚举成员的声明顺序将隐式且顺序的表达它们的值.

> 一般声明冲突或者错误,都会有编辑器提醒你.

# 成员

> 写在我里面就叫我的成员, 受到到我的随意支配.  
> > 但是基类,接口,构造函数和构析函数有些特殊. 这取决于它们本身,或者声明的可访问性.

## 命名空间成员

所有没有封闭的命名空间是 `全局命名空间` 的成员. 这直接对应于它们声明的名称.  

命名空间中声明的其他命名空间和类型是该命名空间的成员.这直接对应于它们声明的名称.
命名空间没有任何访问限制, 不能声明私有,受保护的或内部命名空间,并且命名空间名称始终是可公开访问的.

## 结构成员

`结构成员`是指`值类型成员`,也就是`struct`结构  
他们的成员只包含他们内部声明的成员类型和从值类型基类继承来的成员`System.ValueType`,`object`

## 枚举成员

枚举的成员是枚举中声明的常量,  
以及从枚举的直接基类 `System.Enum` 和间接基类和继承的成员 `System.ValueType`,`object`

* 对于枚举,可以使用其继承写法修改默认值类型,默认值是int
* 即使此类枚举没有保护42的准确值,也不影响你将其转换为此类型
* 这导致接受枚举的函数可能接受到任何值,而不是声明过得有限类型.
* 所以对于纯粹的else或者default就要小心了.他们可能并不是最后一个值(max).而可能是未声明的任何值.
* 处理枚举类型的case.default总是要抛出异常或者警告
* 还好,所有对于基础类型到枚举的转换都是显示的,但0是例外.他可以隐式转换为枚举
* 在枚举中间插入很危险,这会使后面的枚举顺移.导致某些逻辑错误, 避免这个错误的方法是显示赋值



## 类成员

类声明可以包含  
* 
* 常量
* 字段
* 方法
* 属性
* 事件
* 索引器
* 运算符
* 实例构造函数
* 析构函数
* 静态构造函数
* 类型的声明

> `类型的声明`就是说类型可以嵌套.

## 接口成员

就是所有接口.

## 数组成员

来自`System.Array`

## 委托成员

`System.Delegate`

# 成员访问

在访问成员时,根据成员声明时存在的区域,以及指定的可访问性来确认是否可以访问.

## 声明的可访问性

* Public: 含义为 *访问不受限制*
* Private: 含义为 *访问限制为包含类型*,即仅限声明的区域使用.
* internal: 含义为 *访问此程序限制*,即仅限于程序内部访问,可以理解为对自己程序`public`对外部程序`private`
* Protected：含义为 *访问限制为包含类或派生自包含类的类型*,对比`Private`多出了派生类可以访问的权限
* Protected internal: 含义为 *访问此程序或派生自包含类的类型*, 就是上面两个关键字,是`且`关系

当成员声明中不包含任何访问修饰符时,会依据上下文进行判断,给出一个默认的访问权限.

* 命名空间隐式为`public`, 且命名空间声明中不允许使用访问修饰符
* 在编译单元或命名空间中声明的类型可以具有 `public` 或 `internal` 声明可访问性,并且默认为 `internal`
* 类成员可以有全部五种声明的可访问性,默认值为 `private`.
* 结构成员可以有 `public` 、 `internal` 或 `private` 访问性,并且默认为 `private`
* 接口成员隐式 `public` ,接口成员声明中不允许使用访问修饰符。
* 枚举成员隐式 `public` ,枚举成员声明中不允许使用访问修饰符(但枚举本体类似于类)

> 注意: 可访问性是传递的,如果父类`private`,子类就不能是`public`. 编译器会提醒你.

# 签名和重载

签名实际是一种约定, 表示方法,索引器,运算符本来的真实面目.  
编译器的大多数推算都是基于签名的.

*举个例子*  
方法的签名由方法的`名称`、`类型参数的数目`以及其`每个形参的类型和种类` ,按*从左到右*的顺序排列

可见,这其中不包含`返回类型`. 因为编译器难以推断.  
同时也不包括`参数修饰符`和`可选参数约束`

对于任何形式的重载,必须保证每个重载的签名是唯一的,不然调用时就有歧义.  
> 编辑器会提示你.

* `out`和`ref`在C#中被视为修饰符,但为了兼容CLI则不可以用其做推断.  
* `object`和`dynamic`都签名被视为相同类型.
* `params`也不被视为签名的一部分,因为无法区分一个和一群.


# 作用域

略.

* 哪里声明就在哪里使用
* 两个区域都拥有同样签名的内容,以较近的域为准.
* 注意`闭包`.

# 命名空间和类型名称

每个命名空间和类型都有一个 *完全限定的名称*

如`System.Int32`

# 自动内存管理

又称`GC`  

如果对象或它的任何部分不能通过任何可能的执行继续进行访问.  
则将由`GC`进行收集.  
并于一个不确定的时间进行统一销毁.

> 所以实际上被收集但是未被销毁的对象是可以`复活`的...

# 执行顺序

略.

想保证执行顺序建议使用`lock`关键字.

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

[csharpDoc_Link]:https://docs.microsoft.com/zh-cn/dotnet/csharp/ "CSharp官方文档"

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
