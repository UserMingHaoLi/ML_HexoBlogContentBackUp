---
title: hexo模板
date: 2021-08-15 01:50:00
updated: 2021-08-15 01:50:00
id: ml-20210815-015000-g152
categories:
	- 杂文
tags: 
	- 杂文
---


总有些小东西不知道放在哪,就放在这把.



<!--more-->

~~也方便以后摸鱼~~

# 桌面快捷方式直接打开Unity项目

1. 快捷方式直接打开Unity项目
* 编辑快捷方式，在目标后面加空格` –projectPath 你的项目地址(C:\a这样)`

# 摸了一个快排

```C#
static void Main(string[] args)
{
	int min = -100000;
	int max = 100000;
	int forCount = 10000;
	int randCount = 10000;

	Random random = new Random();
	List<int> values = new List<int>();

	for (int count = 0; count < forCount; count++)
	{
		values.Clear();
		for (int i = 0; i < randCount; i++)
		{
			int tmp = random.Next(min, max);
			values.Add(tmp);
		}
		quickSort(values);//快排,上面是出题,下面是验证.

		int pre = min;
		foreach (var item in values)
		{
			if (item < pre)
				throw new Exception();
			pre = item;
		}
		if(count % (forCount / 100) == 0)
			Console.WriteLine($"Count = {count}");
	}
	Console.WriteLine("OK!");
	Console.ReadLine();
}

static void quickSort(List<int> num)
{
	quickSort_Base(num, 0, num.Count - 1);
}

static void quickSort_Base(List<int> num, int l, int r)
{
	if (l >= r) return;
	int value = num[l];
	int left = l;
	int right = r;
	while (left < right)
	{
		while (left < right && num[right] >= value)
		{
			right--;
		}
		Swap(num, left, right);
		while (left < right && num[left] <= value)
		{
			left++;
		}
		Swap(num, left, right);
	}
	quickSort_Base(num, l, left-1);
	quickSort_Base(num, right+1, r);
}
static void Swap(List<int> num, int l, int r)
{
	if (l == r) return;
	num[l] ^= num[r];
	num[r] ^= num[l];
	num[l] ^= num[r];
}
```

# 抄了一个`A*`

有时间再回来理解以下
```C#
public bool FindPath()
{
    openList.Clear();
    closeList.Clear();

    List<Node> neighborList;
    openList.Add(map.startNode);

    while (openList.Count > 0)
    {
        curNode = FindLowestFNode(openList);
        openList.Remove(curNode);
        closeList.Add(curNode);

        if (curNode == map.finishNode)
        {
            return true;
        }

        neighborList = GetNeighborNode(curNode);
        foreach (var item in neighborList)
        {
            if (!closeList.Contains(item))
            {
                if (!openList.Contains(item))
                {
                    openList.Add(item);
                    item.parentNode = curNode;
                    item.G = curNode.G + GetDistance(curNode, item);
                    item.H = GetDistance(item, map.finishNode);
                }
                else
                {
                    int newG = curNode.G + GetDistance(curNode, item);
                    if (newG < item.G)
                    {
                        item.G = newG;
                        item.parentNode = curNode;
                    }
                }
            }
        }
    }

    return false;
}

//获取寻路的路径
private void GetPath()
{
    path.Clear();
    Node node = map.finishNode;

    while (node != null)
    {
        path.Push(node);
        node = node.parentNode;
    }

    //获取到路径的事件
    if (OnGetPath != null)
        OnGetPath(path);
}

//找到最小F值的node
private Node FindLowestFNode(List<Node> array)
{
    Node node = array[0];
    foreach (var item in array)
    {
        if (item.F <= node.F)
            node = item;
    }
    return node;
}

//获取指定的两个节点间的理想距离，允许对角移动
private int GetDistance(Node fromNode, Node toNode)
{
    int x = Mathf.Abs(fromNode.location.x - toNode.location.x);
    int y = Mathf.Abs(fromNode.location.y - toNode.location.y);

    return x > y ? 10 * (x - y) + 14 * y : 10 * (y - x) + 14 * x;
}

//获取一个节点的周围所有节点
private List<Node> GetNeighborNode(Node centerNode)
{
    List<Node> neighborList = new List<Node>();
    Node node;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            if (!(i == 0 && j == 0))
            {
                node = map.FindNode(centerNode.location.x + i, centerNode.location.y + j, map.groundList);
                if (node != null)
                {
                    //判断四角的节点是否与障碍物相邻
                    if ((i == -1 || i == 1) && (j == -1 || j == 1))
                    {
                        if (map.FindNode(centerNode.location.x + i, centerNode.location.y, map.obsList) != null
                        || map.FindNode(centerNode.location.x, centerNode.location.y + j, map.obsList) != null)
                            continue;
                    }
                    neighborList.Add(node);
                }
            }
        }
    }

    return neighborList;
} 作者：奥飒姆_Awesome https://www.bilibili.com/read/cv12595386 出处：bilibili
```


# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->
[UMLClassMode]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/%E6%A8%A1%E6%9D%BF/UML%E7%B1%BB%E5%9B%BE%E6%A8%A1%E6%9D%BF.png "UML类图模板"
<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
