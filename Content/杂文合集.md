---
title: 杂文合集
date: 2021-08-15 01:50:00
updated: 2021-08-15 01:50:00
id: ml-20210815-015000-g152
categories:
	- 杂文
tags: 
	- 杂文
---


总有些小东西不知道放在哪,就放在这把.



<!--more-->

~~也方便以后摸鱼~~

# 桌面快捷方式直接打开Unity项目

1. 快捷方式直接打开Unity项目
* 编辑快捷方式，在目标后面加空格` –projectPath 你的项目地址(C:\a这样)`



# 抄了一个`A*`

有时间再回来理解以下
```C#
public bool FindPath()
{
    openList.Clear();
    closeList.Clear();

    List<Node> neighborList;
    openList.Add(map.startNode);

    while (openList.Count > 0)
    {
        curNode = FindLowestFNode(openList);
        openList.Remove(curNode);
        closeList.Add(curNode);

        if (curNode == map.finishNode)
        {
            return true;
        }

        neighborList = GetNeighborNode(curNode);
        foreach (var item in neighborList)
        {
            if (!closeList.Contains(item))
            {
                if (!openList.Contains(item))
                {
                    openList.Add(item);
                    item.parentNode = curNode;
                    item.G = curNode.G + GetDistance(curNode, item);
                    item.H = GetDistance(item, map.finishNode);
                }
                else
                {
                    int newG = curNode.G + GetDistance(curNode, item);
                    if (newG < item.G)
                    {
                        item.G = newG;
                        item.parentNode = curNode;
                    }
                }
            }
        }
    }

    return false;
}

//获取寻路的路径
private void GetPath()
{
    path.Clear();
    Node node = map.finishNode;

    while (node != null)
    {
        path.Push(node);
        node = node.parentNode;
    }

    //获取到路径的事件
    if (OnGetPath != null)
        OnGetPath(path);
}

//找到最小F值的node
private Node FindLowestFNode(List<Node> array)
{
    Node node = array[0];
    foreach (var item in array)
    {
        if (item.F <= node.F)
            node = item;
    }
    return node;
}

//获取指定的两个节点间的理想距离，允许对角移动
private int GetDistance(Node fromNode, Node toNode)
{
    int x = Mathf.Abs(fromNode.location.x - toNode.location.x);
    int y = Mathf.Abs(fromNode.location.y - toNode.location.y);

    return x > y ? 10 * (x - y) + 14 * y : 10 * (y - x) + 14 * x;
}

//获取一个节点的周围所有节点
private List<Node> GetNeighborNode(Node centerNode)
{
    List<Node> neighborList = new List<Node>();
    Node node;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            if (!(i == 0 && j == 0))
            {
                node = map.FindNode(centerNode.location.x + i, centerNode.location.y + j, map.groundList);
                if (node != null)
                {
                    //判断四角的节点是否与障碍物相邻
                    if ((i == -1 || i == 1) && (j == -1 || j == 1))
                    {
                        if (map.FindNode(centerNode.location.x + i, centerNode.location.y, map.obsList) != null
                        || map.FindNode(centerNode.location.x, centerNode.location.y + j, map.obsList) != null)
                            continue;
                    }
                    neighborList.Add(node);
                }
            }
        }
    }

    return neighborList;
} 作者：奥飒姆_Awesome https://www.bilibili.com/read/cv12595386 出处：bilibili
```

# 框架设计

如何开发一个框架，或者如何搭建，如何设计一个框架

> 减少轮子
是否市面上也有这样的轮子。如果有，那么新造的轮子要解决什么问题，或者对比现有的轮子有什么优势。是否可以加入其他轮子的开发

> 在全局和细节的平衡

如果是框架开发新手，推荐是从大框架开始而不是从细节入手

两个眼睛单独看是挺好看，合到一起，咋是歪的呢？啊？咋办，擦了重来，扣两小时细节白搭

> 方便扩展

如果新添加一个扩展，在业务端需要写的代码量有多少是业务无关的

需要写半天的业务无关的用于接入框架的代码，同时需要修改很多个不同项目的很多个函数的代码，求业务开发者心理阴影面积

> 方便静态阅读

假定所有的方法调用等，都进入框架绕一圈出来，所有的传入和传出的参数或执行函数都是抽象的接口定义，或者充满委托，那此时静态代码阅读基本阵亡

如果静态代码阅读不能理解逻辑含义，这就意味着在新增功能或者变更逻辑的时候，将会修改不全面，或者作出了不符合框架预期的行为

*静态代码阅读具体和框架的抽象设计相关，抽象设计等级越高，意味着通用性更强，也意味着静态阅读难度越高，理解难度越高。但如果有清晰的文档，那上文的问题将可以解决*

> 方便调试

> 对 API 进行分层

对于高级的用法需要放在里层，如 Foo.F2.F3() 的方式，这样可以减少开发者用错

大部分的功能，简单的功能都是对高级的用法的封装，这就意味着对于用户来说，如果绕过调用简单的用法，而使用高级的用法，也是能达到预期效果的

然而很多高级的用法都有细节，对于不熟悉框架的用户，绕过简单的方法，调用高级用法，也许会忽略某些细节，从而在某些分支效果不符预期

方法里面做了一些封装，如判断了一些属性以及预先调用一些初始化方法

*对 API 的分层，其实就是分开用户的等级，对于不熟悉的用户，大部分的简单用法都能让用户符合预期，同时也没有什么坑。但是用户如果期望进行更多定制，那么将在框架开发者指导下，或者用户熟悉框架，调用高级的方法*

> 遵守默认约定

如关闭某个功能，如果叫 Close 那就是比较通用的，而如果叫 Exit 尽管能达意，但是开发者也许找不到此方法

> 统一性设计

维护好统一性设计的优势在于减少理解成本，无论是框架的维护者还是框架的使用者都可以使用更少的知识进行维护和使用框架

所有的代码写起来的逻辑都是相近的，无论是重新阅读代码还是新写代码，都可以复用原有的知识。可以很大的降低新手加入项目的恐慌

举一个反面的例子，假定有一个框架在设计上是如此的：对于 A 业务资源的定义上，要求使用 Id 作为唯一标识符；对于 B 业务资源的定义上，要求使用 Name 作为唯一标识符；对于 C 业务资源的定义上，要求使用 Key 作为唯一标识符

如在 dotnet 里面，特性采用 Attribute 后缀，如异常使用 Exception 后缀，事件参数使用 EventArgs 后缀等。这样的设计就体现了设计的统一性

在 dotnet 里面，类的设计上，可以采用接口约束来实现统一性。这是基础的面向对象的封装，但是这里需要说明的是，足够抽象的底层接口，可以让更多的上层框架采用此接口的元素，从而实现上层框架的统一

> 不同的逻辑截然不同

和上文的统一性设计相对的是，如果两个不能混淆的逻辑放在一起，那么将这两个逻辑设计为截然不同的风格可以让业务开发者不会混淆

例如有业务是简单从内存移除某个文件的记录，另一个业务是从本地磁盘永久删除某个文件。那么对于此两个不同的等级的方法的设计上，就可以采用不同的命名方式，甚至要求传入不同的参数来进行区分

**不同的逻辑截然不同指的是那些好混淆的逻辑，而不是让每个模块各自为政**

> 开发时做好防逗比

按照优先级，最高的是构建不通过，其次是运行时抛调试异常，其次是写注释，其次是写文档

实现一个解析某个类型文件的函数，请问此函数的参数里面如果要传入文件，那参数的类型是字符串还是 FileInfo 类型好

我在调用某个函数进行画矩形，这个函数里面的参数是 int 值，请问我是否应该传入 10 进去？如果我期望画出的是一个 10 厘米的矩形呢？如果画矩形的方法没有告诉我参数的单位，那么只能按照经验进行猜测，而如果画矩形函数有明确给定参数类型是 Pixel 类型，那么我自然就了解需要传入的是像素

大量的 Win32 函数会返回某个错误码

然而当前是现代，不妨修改为抛出异常，给出大量的内部细节，告诉开发者用户为什么出错了，此时开发者用户可以省去查阅文档，了解错误码对应的信息的工作

# StringInfo

通过 `StringInfo` 类的辅助，可以获取可视效果下的字符串的字数

```C#
var info = new StringInfo("དིོེུ");
var realLength = info.LengthInTextElements; // realLength = 1
```

遍历藏文，需要使用 `StringInfo.GetTextElementEnumerator` 方法，例子如下

```C#
var enumerator = StringInfo.GetTextElementEnumerator("ཀྲུང་ཧྭ་མི་དམངས་སྤྱི་མཐུན་རྒྱལ་ཁབ།");
while (enumerator.MoveNext())
{
    Console.WriteLine(enumerator.GetTextElement());
}
```

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->
[UMLClassMode]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/%E6%A8%A1%E6%9D%BF/UML%E7%B1%BB%E5%9B%BE%E6%A8%A1%E6%9D%BF.png "UML类图模板"
<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
