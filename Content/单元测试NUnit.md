---
title: 单元测试NUnit
date: 2021-03-24 20:56:00
updated: 2021-03-24 20:56:00
id: ml-20210324-205600-g101
categories:
	- 基础
	- 单元测试
tags: 
	- 基础
	- 单元测试
	- CSharp
---

之所以选择`NUnit`是因为`Unity`的测试也是这玩意.  
这是开源的,你可以在`GitHub`找到它的源码.  
本文为阅读`单元测试之道`后编写.

<!--more-->

# 安装NUnit

虽然你可以使用vs自带的`MSTest`, 但是NUnit也是不错的选择.  
在NuGet包管理器中搜索安装`NUnit` `NUnit3TestAdapter` 这样你就可以在创建单元测试的时候使用NUnit了

# 测试内容

你可能需要一些指导, 应该怎么选择测试代码.  
编写测试的时候, 你需要思考下面的问题

> 你可能需要一些本地配置文件用于测试, 由于是你自用且不会发布的, txt就够了.  
>如果出现错误, 你可能需要检查一下数据是否错误或者过时了.. 相比于每次都全额通过的测试代码, 文件或参数出错的可能性更高.

> 不一定需要满足以下全部条件, 你应该按需增加测试内容.

## 结果是否正确

就是以正常的输入是否能得到预期的结果  
如果你不知道什么是正确的输入或预期的结果, 你可能需要再次观看文档或者询问相关人员.

> 需求是变化的, 这一项也可能发生变化.

## 边界是否检查过了

很好理解, 你需要参数的极限值, 比如 0个,1个,Max个,或者实际参数的边界值 Max Min什么的.

> 例子

* 完全伪造的**不可能数据**, 比如一串乱码.
* **错误的格式**, 比如没有结尾的邮箱号.
* **空值**或者**部分空值**, 这里包含"",0,null
* 一些代码上合理单**逻辑不合理**的数据, 比如年龄=10000
* 输入**明显不满足**的数据, 比如要求一个连续数字, 你给一个不连续的.
* **颠覆顺序**, 比如没有登录就尝试消费.

需要满足以下内容

* 和预期一致的或非一致的
* 顺序的或乱序的
* 引用外部代码的
* 不存在的
* 范围内地和范围外的
* 不满足基本条件的
* 满足顺序和不满足顺序的

## 检查反向内容

如果你向数据库插入一条数据, 你可能需要查询数据库来校验是否成功.

> 此时不应该使用你自己的代码, 或许可以尝试原生的无错代码, 以免*双向错误*.  
> 也可以使用经过验证的代码,但是记住,**一次只修改其中的一项**.

## 交叉检查结果

通常有多重方法满足条件, 为一种编写测试, 用另一种验证结果.

## 是否拥有强制错误抛出

是否有异常处理机制.

* 网络异常
* 磁盘异常(IO)
* 时钟问题
* 内存占用问题
* 分辨率问题

> 基本的Null只是小儿科

## 是否满足性能要求

运行时间如何?

有适合一个算法可能因为输入增多而指数级的消耗性能. 你可能需要编写一些针对性的测试.  
这些测试通常都很消耗性能或者时间, 你可以将他们归类, 之后每天晚上(每周)测试一次.

```
最好的编写测试方法是, 编写一个测试后, 询问自己还有什么可能错.
```

# 特性

特效类似于这样`[Test]`,是一种C#语法,为代码添加额外的元数据

## Category

**分组**  

他有一个string的参数, 你可以指定一个方法的组名.  
这样就可以在视图中使用分组依据-特征. 来按照你规定的string显示分组. 任意组合并运行他们

可以用于类, 这样整个类都是该类型.

*如果一个方法有多个分组, 那么它显示多次, 但实际上还是只执行了一次.*

## Explicit

**跳过**

除非手动选定, 否则不会执行. 可以用于较为耗时的方法.

## SetUp

**预处理**

此方法在每个测试开始前运行一次

## TearDown

**收尾**

对应上面, 但这个是每次结束运行一次

## OneTimeSetUp

**预处理**

类级别的Up, 在每个类初始化的时候调用一次.

## OneTimeTearDown

**收尾**

同上, 类完成的时候结束一次.

## Igonre

**忽略**

不执行这个测试, 可以用于正在编写实现代码的测试.  
虽然你可以不使用这个特性, 因为你知道这个代码不会通过, 但是无论如何, 不要养成忽略失败测试的习惯, *每个测试都应该保持通过状态*, 不然单元测试就失去了意义.



# 断言

不建议无止境的Copy代码, 应该在测试代码中使用和生产代码一样的标准.  
你可能需要一些自定义的断言, 通过下面的断言组合而成

另外要说的是, 异常是彻头彻尾的好东西, 测试本身就是发现问题的, 看到异常我们应该高兴.

## AreEqual()

传入两个参数, 第一个是你的预期值, 第二个是测试得出的结果. 这两个值必须相等.  
如果你使用断言来指定浮点数, 那么你需要指定一个误差数据.

## IsNull

一定为Null

## AreSame

引用相等(地址比较)

## IsTrue

一定为True

## IsFalse

为False

## Fail

立刻失败, 等同于 IsTrue(false)

> 不建议使用,应该对比结果或者条件.

## Throws<T>

执行一个Action, 他里面应该有T类型的异常被抛出来.  如果没有该异常, 测试失败

> 如果触发了异常, 立刻通过, 代码就停止运行了.

> 此方法替换了之前的Exception属性.

# 注意事项

> 任何索引都应该被大量测试

> 除了检测结果,你还应该检测状态变化

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->


<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
