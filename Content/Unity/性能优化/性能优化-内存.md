---
title: 性能优化-内存
date: 2023-06-11 17:20:00
updated: 2023-06-11 17:20:00
id: ml-20230611-172000-g191
categories:
	- Unity
	- 性能
	- 内存
tags: 
	- Unity
	- 性能
	- 内存
---


主要思路就是
- 资源
  - 各种压缩方式, 读取方式
- 渲染
  - 效果越好, 自然内存占用越高, 合批减少CPU开销, 但也可能增加内存(显存)占用
- 代码
  - 内存碎片
  - 内存泄漏
  - 内存对齐(缓存命中率, 提升性能)

<!--more-->

# 物理内存

CPU访问内存是一个慢速过程  
如果能命中CPU中的L1,L2,L3缓存, 速度将大幅提升

参考ECS, 有效提升缓存命中率

# Unity内存管理

Unity底层由C++编写, 且我们编写的C#代码, 最后也被IL2CPP编译为Native C++

所以自然的, 里面就有非托管内存, 当然, IL2CPP还是提供了CG回收的托管内存区间

> Unity在Editor和Runtime下，内存的管理方式是不同的

## Native Memory 原生内存

不会被系统自动管理，需要手动去释放

Unity在里面重载了C++的所有分配内存的操作符，例如alloc，new等, 主要是为了添加Memory Lable  
指当前的这一块内存要分配到哪个类型池

> 有标签就可以监控, 然后重用

因为是C++的，所以当delete或free的时候，会立刻返回给系统

### 优化 Native Memory

> 需要在内存和效果上做取舍, 有时候就是需要更多内存来展示更好的效果

- GameObject过多, 每个都会反映到C++
  - 使用Destroy将回收内存, 置为null不会回收
- 短期数据使用结构, 长期数据使用类型
  - 结构不进入Native Memory
  - Enum全程占用内存
- 永不关闭的协同也将永远持有其数据, 如果有闭包参与, 则其关联内存也无法释放
- 声音
  - 强制单声道, 多声道会多一倍内存
  - Compression Format, 进行平台适配的压缩, 减少内存压力
  - 静音处理, 如果只是音量=0, 还是会占用内存
  - LoadType, 合适的加载方式能显著减少内存占用
  - 使用Vorbis/MP3格式, 占用更少内存(iOS推进MP3, 有硬件解码)
- 代码大小, IL2CPP会单独编译每个泛型(值类型泛型会被展开更多代码)
- AssetBundle
  - TypeTree, Unity用于适配跨版本情况, 如果上一个版本的类型在这个版本没有，那TypeTree里就没有它，所以不会去反序列化这个类型, 确认同版本的情况下, 可以关闭TypeTree减少大小
  - 压缩, LZ4解压可重用内存块(ChunkBased)
  - 大小和数量, 每个AssetBudle会携带一个头数据(索引), ab数量过多可能头的部分比数据还大, 推进每个ab有1M以上
- Resource, 启动时全部索引加载到内存, 注意大小
- Texture
  - Read/Write, 占用双倍内存
  - Mip Maps, 生成更多小尺寸的图片, 占用内存
  - Format, 合适的平台格式可显著减少内存(显存)
    - 现在主流使用ASTC(主流使用4,5,6 block), 如果要向下兼容更多机型, 则考虑ETC, PVRTC
    - Android, ETC, ETC2, ASTC
    - iOS, PVRTC, ASTC
  - alpha, 不透明纹理不需要
  - Max Size, 个平台选取合适的最大尺寸
  - POT, 有些平台需要2次幂, 不选择平台自动处理就会消耗更多内存
  - 合并, 图集合并, 多张纹理也可以按项目需求合并
- Mesh
  - Read/Write, 占用两倍内存
  - Compression, 压缩后减少磁盘占用, 运行时内存占用并不会减少, 有些格式对内存可能有负面影响
- Graphics
  - 合批, 会加大内存占用, 因为包含更多数据
  - Shadows, 谨慎使用
  - Light, 推荐按层使用
  - 分辨率, Screen.SetResolution 来降低游戏预设的解析设置
  - 使用多档预设画质配置, 并依据机型,FPS等数据切换
- UI
  - 数量过多
  - 频繁显示隐藏
  - 频繁刷新刷新
  - 合批
  - 全屏UI的处理, 可以关闭背后的其他渲染
- 数据结构
  - Array，List和Dictionary等会进行2倍扩容, 容易导致内存增长和碎片, 直接分配起始大小更好

## Managed Memory 托管内存

自动的，会通过GC来释放

GC 不会把内存返还给系统  
一个 Block 连续六次 GC 没有被访问到，这块内存才会被返还到系统  
不会频繁地分配内存，而是一次分配一大块

当有内存被回收的时候，空的地方不会重新排布  
所以有内存碎片化一说, 即有很多内存空间, 但所有可用内存块都太小了,无法分配给新申请的内存, 就只能重新开辟了.

代码写的不好也会存在疑似泄露的内存, 比如持有只是用一次的资源

### 优化 Managed Memory

- 减少装箱拆箱操作
- 使用对象池
- 减少闭包和匿名函数
- 协程, 闭包的特例, 可能存在很长时间, 要注意其捕获的数据
- 配置表, 分段加载, 按需加载
- 单例, 会恒定占用内存, 不需要了建议手动释放, 或者跳场景释放一次
- 共享数据
- 属性, 函数的调，会在堆栈上分配内存
- 缓存数据
- 缓存对象

# 堆栈

内存中存储函数和值类型的地方  

调用不结束, 这些值和函数都会存在于其上  
所以各种Debug可以打印函数对战

如果一直push东西进堆栈，占内存空间，导致堆栈溢出

# 堆积

比堆栈大, 引用类型存放

创建一个新的对象，会在堆积中找到一个足够存放的空位置  
放不下的情况下，堆积会膨胀，并且每次都增长两倍，且不会再缩回去  
销毁对象后，内存不会马上释放，而是标记成未使用，等待GC  
GC释放的内存过多, 过频繁, 容易形成卡顿



# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
