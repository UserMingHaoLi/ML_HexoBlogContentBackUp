---
title: 类解析-Object
date: 2021-05-18 20:50:00
updated: 2021-05-18 20:50:00
id: ml-20210518-205000-g141
categories:
	- 基础
	- CSharp类详解
tags: 
	- 基础
	- CSharp类详解
	- CSharp
---


- [System中的接口](#system中的接口)
	- [IAsyncDisposable](#iasyncdisposable)
	- [IAsyncResult](#iasyncresult)
		- [AsyncState](#asyncstate)
		- [AsyncWaitHandle](#asyncwaithandle)
		- [CompletedSynchronously](#completedsynchronously)
		- [IsCompleted](#iscompleted)
	- [ICloneable](#icloneable)
	- [IComparable](#icomparable)
	- [IComparable<T>](#icomparablet)
	- [IConvertible](#iconvertible)
- [完毕](#完毕)


<!--more-->

# System中的接口


## IAsyncDisposable

是老朋友`Disposable`的异步版本  
表示异步释放

* `DisposeAsync()`	
  * 以异步方式执行与释放或重置非托管资源相关的应用程序定义的任务。

使用此方法（而不是 `IDisposable.Dispose` ），可以在不阻止 `GUI` 应用程序的主线程的情况下执行占用大量资源的释放操作

> 异步方法与 `async` `await` 配合使用更佳

您可以在以下情况下实现 `IAsyncDisposable`

* 开发拥有非托管资源的异步枚举器时
* 释放资源需要消耗大量性能

扩展方法 `ConfigureAwait(IAsyncDisposable, Boolean)	`  
配置如何执行从异步可处置项返回的任务的等待

## IAsyncResult

表示异步操作的状态

* `AsyncState`	
  * 获取一个用户定义的对象，该对象限定或包含有关异步操作的信息。
* `AsyncWaitHandle`	
  * 获取用于等待异步操作完成的 WaitHandle。
* `CompletedSynchronously`	
  * 获取一个值，该值指示异步操作是否同步完成。
* `IsCompleted`	
  * 获取一个值，该值指示异步操作是否已完成。

### AsyncState

```C#
public object? AsyncState { get; }
```
可以看到是一个`Object`, 用户定义的任何类型都可以放在里面

### AsyncWaitHandle

```C#
public System.Threading.WaitHandle AsyncWaitHandle { get; }
```

`System.Threading.WaitHandle`有点复杂, 一般使用

* `WaitOne()`
  * 阻止当前线程，直到当前 `WaitHandle` 收到信号

### CompletedSynchronously

```C#
public bool CompletedSynchronously { get; }
```

如果在委托中检测到调用的同步完成 `AsyncCallback` ，则启动异步操作的线程可能是当前线程

例如 如果 `i/o` 请求太小, 可以直接在主线程完成

### IsCompleted

```C#
public bool IsCompleted { get; }
```

可以使用属性来轮询完成

```C#
 while(result.IsCompleted == false) {
                Thread.Sleep(250);
                Console.Write(".");
            }
```

## ICloneable

支持克隆，即用与现有实例相同的值创建类的新实例

* `Clone()`	
  * 创建作为当前实例副本的新对象

该方法旨在提供超出`Object.MemberwiseClone`的克隆支持. 即深拷贝.

建议 `ICloneable` 不要在公共 api 中实现,因为使用者并不理解此次拷贝的深度如何.

## IComparable

定义由值类型或类实现的特定于类型的通用比较方法，旨在对其实例进行排序

* `CompareTo(Object)`	
  * 将当前实例与同一类型的另一个对象进行比较，并返回一个整数，该整数指示当前实例在排序顺序中的位置是位
  于另一个对象之前、之后还是与其位置相同。

很多提供排序的方法都会要求被排序单位实现此接口,如`Array.Sort` `ArrayList.Sort`

其返回值含义如下

* 小于零	
  * 当前实例 `CompareTo` 在排序顺序中位于方法所指定的对象之前。
* 零	
  * 此当前实例与方法所指定的对象在排序顺序中出现的位置相同 `CompareTo`
* 大于零	
  * 此当前实例 `CompareTo` 在排序顺序中跟随方法所指定的对象。

> 由于参数为`Object`,需要注意装箱拆箱, 推荐使用泛型模式,性能好点.  
> 对于比较性质的方法,注意**相等性**的各种条目(对称,交换,传递,重复可靠).  
> 既然有相等性.最好也实现相等性比较相关内容

## IComparable<T>

上面`IComparable`的泛型版本,减少性能消耗,装箱拆箱问题.

* `CompareTo(T)`
  * 同上

通常由` List<T>.Sort()`这种排序方法调用,要求`Item`实现此接口

## IConvertible

**此 API 不符合 CLS**

定义将实现引用或值类型的值转换为具有等效值的公共语言运行时类型的方法

* `GetTypeCode()`	
  * 返回此实例的 TypeCode。
* `ToXXXX(IFormatProvider)`	
  * 使用指定的区域性特定格式设置信息将此实例的值转换为等效的 `XXX` 值, 此种函数有多个,如`ToInt16`,`ToInt32`等待...

我们自己一般不会继承此接口.通常直接使用`Convert`类

大多数转换方法具有类型为的参数 `IFormatProvider` ，该参数表示当前区域性 (`CurrentCulture`) 或特定区域性。 大多数情况下， `IConvertible` 基类型的实现会忽略此参数。 但是，你自己实现的话可以选择是否在代码中使用它

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
