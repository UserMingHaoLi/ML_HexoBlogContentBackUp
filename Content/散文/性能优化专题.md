---
title: 性能优化专题
date: 2021-11-01 23:39:00
updated: 2021-11-01 23:39:00
id: ml-20211101-233900-g166
categories:
	- 性能优化
tags: 
	- 性能优化
---

性能无非是CPU,GPU,内存

<!--more-->

# CPU的优化

## DrawCalls

`DrawCall`是CPU调用底层图形接口  
一个 `Draw Call`，等于呼叫一次 `DrawIndexedPrimitive (DX)` 或`glDrawElements (OGL)`

虽然具体图像是由GPU处理, 但是计算如何什么数据还是有较大开销的

对DrawCall的优化，主要就是为了尽量解放CPU在调用图形接口上的开销

* 使用`Draw Call Batching`，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们
* 通过把纹理打包成图集来尽量减少材质的使用
* 尽量少的使用反光啦，阴影,抗锯齿,水面倒影,后处理之类的，因为那会使物体多次渲染

## Draw Call Batching

被`批处理`的2个物体的网格模型需要使用相同材质的  
为了将2个纹理不同的材质合二为一,就需要将纹理打包成图集  
这样我们就可以只用一个材质来代替之前的2个材质了

### Static Batching 

只要这些物体不移动，并且拥有相同的材质，静态批处理就允许引擎对任意大小的几何物体进行批处理操作来降低描绘调用  

需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放

需要在Inspector中将Static复选框打勾即可  之后他们会被统计到`Saved by batching`中.

### Dynamic Batching

* 批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体  
* 如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体  
* 不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理
* 统一缩放的物体不会与非统一缩放的物体进行批处理
  * 使用缩放尺度(1,1,1) 和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1) 和(1,3,1)的两个物体将可以进行批处理
  * `GameObject has a scale of 1 and another GameObject has a scale of –1, Unity can’t batch them together`
  * 对于缩放来说, 等比缩放和非等比缩放的物体会分开处理
* 如果物体Shader有Multi-pass会中止批量处理
* 使用不同材质的实例化物体（instance）将会导致批处理失败
* 拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）
* 多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道
* 预设体的实例会自动地使用相同的网格模型和材质
* 物体接收实时阴影不会纳入批处理

Dynamic batching过程中，会计算下一个mesh需要的顶点索引数目，如果vertex index 超过32000（引擎源码中`kDynamicBatchingIndicesThreshold`）时，将停止当前批次

如果GPU负载品瓶颈，CPU负载又相对宽裕，可以尽可能符合dynamic batching, 反之则需要谨慎使用

## 物理组件

* 设置一个合适的Fixed Timestep
  * 和Update主帧循环不同，Unity的刚体系统通过固定的时间来驱动，固定的运算时间是保证模拟结果准确一致的重要因素
  * 游戏的主循环（Update）必须在在常规的物理运算FixedUpdate()调用之间进行,其实就是浪费了计算资源，因为中间的计算的结果是不会显示的
* 不要使用网格碰撞器（mesh collider）

## GC

GC处理的是内存, 但是是GPU调用的.  

对于GC的优化目标就是尽量少的触发GC

U3D引擎也有自己的内存堆而不是和Mono一起使用所谓的托管堆  
GC不是用来处理引擎的assets（纹理，音效等等）的内存释放的  
关注的对象无外乎就是类实例，字符串，数组这些

## 脚本

每个项目不同  
就是优化下Forech, Linq这种,Enumerator还是很耗的,特别是循环中

# GPU的优化

* 填充率，可以简单的理解为图形处理单元每秒渲染的像素数量。
* 像素的复杂度，比如动态阴影，光照，复杂的shader等等
* 几何体的复杂度（顶点数量）
* 当然还有GPU的显存带宽

无外乎就是顶点性能和像素性能.

* 减少像素渲染`OverDraw`
* 减少顶点数量，简化计算复杂度。
* 压缩图片，以适应显存带宽。

材质的数目尽可能少
使用图集
使用光照纹理(lightmap)而非实时灯光
使用LOD
遮挡剔除

压缩图片，减小显存带宽的压力

> 在unity中，一张`512 * 512`的`RGBA 32`位的贴图，在不开启`mipmap`的条件下内存占用正好是`1.0MB`

```CSharp
1.0MB = 512 * 512 *32 / 8(Byte = 8 bit) / 1024 / 1024 (1MB)
```
*需要4华人512填满1024,但32位真彩正好是4个Byte*  
*RGBA每个单字占1Byte*

ASTC比RGBA小4倍

> ETC / ETC2仅支持分辨率长、宽均为4的倍数的贴图, 不过一般都是用2幂,所以天然符合  
> ETC1没有透明通道

> 默认贴图是"black"时，如果贴图缺省，默认值是(0,0,0,0)，A通道读取出来是0，使用RGB ETC2 4bits格式时，A通道读取出来是0，使用ASTC格式时，A通道读取出来是1。这里要注意Shader默认值的考虑

2的幂是因为光栅化需要对纹理采样进行快速取值，由此约定所有传入表面（Surface）必须是2的幂。现在的做法一般是驱动层（或引擎层）做了一次纹理过滤把非2幂的纹理拉伸或压缩到2的幂再传入（比如Mipmap层级），由此实现允许任意纹理传入。但因为基于这个原理非2幂会导致纹理非等比变形，所以对于需求上严格要求像素对齐的大部分情况还是需要美术按照这个规则来定制图片



# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->

<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
