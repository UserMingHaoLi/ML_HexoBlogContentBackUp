---
title: 渲染管线概述
date: 2021-10-31 14:54:00
updated: 2021-10-31 14:54:00
id: ml-20211031-145400-g165
categories:
	- 渲染管线
tags: 
	- 渲染管线
---

[【教程】技术美术入门：渲染管线概述][【教程】技术美术入门：渲染管线概述]

![1UnityBuild-In渲染管线-Kerry佬][1UnityBuild-In渲染管线-Kerry佬]

<!--more-->

# 渲染管线概述

> 看`ame101`,`shader入门精要`

渲染是将模型生成为图像的操作,分为离线(电影)和实时(游戏)

> 简单来说就是我们将模型,贴图,等一系列信息交付给渲染管线,他就做一些规定好的流程来转化为图像  
> 就像一般的生命周期概念,什么时间做什么事情

**软件和硬件的不同,会导致渲染管线的步骤流程不同**,不存在全世界通用的渲染管线这种标准

当然,我们肯定是以Unity渲染管线为例子,分为`CPU`和`GPU`, 一般说的都是指`GPU`渲染,但实际CPU也在里面出了很多力的

蓝色部分是CPU的工作,绿色是GPU做的

有点像是按下快门,之后会有一张图片出来,也就是一份2D像素点集.

*如何处理多摄像机情况呢*

同深度的情况下渲染后来的摄像机内容,主要是由于摄像机在渲染前会进行清除指令, 摄像机组件上有一个属性`Clear Flags` 用于指定不清除什么, 一般是不清天空盒

层级`Depth`越小越先渲染, 然后后渲染的执行清除,在继续渲染. 所以看到的画面往往是后出现的摄像机内容

# CPU渲染管线

## 剔除(Culling)

要渲染谁

![2CPU渲染-剔除-Kerry佬][2CPU渲染-剔除-Kerry佬]

### 视锥体(Frustum Culling)

依据摄相机参数`FOV(视角)`,`CelipPingPlanes近裁面和远裁面`组成一个锥台, 物体与锥台相碰撞,不在其内的就被剔除

但是对于复杂模型,碰撞性能消耗很大,所以通常会给一个AABB(BoundDing Box)包围盒

### 层级剔除(Layer Culling Mask)

在Unity的Camera中有`CullingMask`不在此范围内的层级不会被此Camera渲染

> 物体的层级由`Layer`属性指定

## 遮挡剔除(Occlusion Culling)

在GameObject的`Tag`中选择`Occlusion Static `和` Occludee Static`

其中透明物体，以及小物件，都不可能阻挡其他的东西，应标记为`Occludees`

这意味着它们将被视为能被其他物体遮挡，但不会被视为作为遮挡物自身，这将有助于减少计算量

#### 窗口操作(Window->Occlusion Culling)

打开遮挡剔除窗口`Window->Occlusion Culling`

> TODO ML 具体窗口操作待完善,需看文档,实际操作

感觉类似寻路, 需要预处理

## 排序(Sort)

按什么顺序渲染

> 确认顺序后,就要逐个*提交到GPU*了.

![3CPU渲染-排序-Kerry佬][3CPU渲染-排序-Kerry佬]

### 渲染顺序(RenderQueue)

一般可以在材质中指定这个数值

通过是否是透明队列来决定排序规则, 排序数值是与摄像机的距离

不透明的话,后渲染的物体由于距离较远,被覆盖的部分在2D的时候不会显示,所以不用处理,有性能优化

半透明的则需要叠色,所以要从后往前,全部渲染,开销较大  
而且对于半透明的物体,还有一个渲染的正确性的问题,叠放的顺序不一样,颜色时会有很大差异的

#### 不透明队列(RenderQueue < 2500)

> 实际是`RenderQueue <= 2500`, 但不建议使用2500这个关键值

摄像机从前往后渲染

#### 半透明队列(RenderQueue > 2500)

摄像机从后往前渲染

> 但是,只能保证物体与物体的顺序为从后往前.  
> 对于物体内部的复杂结构,则很难处理, 是目前的前沿领域, 所以*看到半透明物体的奇怪表现,可以怀疑一下内部复杂排序*

> 遇到这种问题, 解决方法有几种`完全不用半透明`, `选取一些部分不使用半透明`,`定制渲染管线自己对顶点排序`

## 打包数据(Batch)

![4CPU渲染-打包数据-Kerry佬][4CPU渲染-打包数据-Kerry佬]

### 模型信息

模型的本质是什么

一般建模软件使用四边形方式建模,但是游戏软件识别后都是三角面,这是为了适配手机

![5CPU渲染-打包数据-模型的源码-Kerry佬][5CPU渲染-打包数据-模型的源码-Kerry佬]

#### 顶点坐标(Vertices)

可以看到,源码中的第一部分就是顶点坐标,一个立方体共8个顶点, 每个顶点有XYZ三个坐标数据

所以最后一句是`8Vertices`

#### 法线(vertex normals)

这里写着`6 vertex normals`

通过建模软件可以看到, 每个顶点实际关联三个面,所以应该有三条法线  
但实际每个面的四条法线是重复的,所以被合并成了一条法线,6个面就是6条法线

#### UV(texture coords)

`4 texture coords`

UV是一组记录着模型上的贴图应该怎么贴，贴在那里的数据

也是由于重复, 数据只有4条

> UV是一个二维数据, 第三个分量是没用的,可以删除

#### 索引列表 (polygons triangles)

`0 polygons - 12 triangles`

表示0多边形 12个三角面.

用于规定那些数据组成一个三角面  
一个三角形包含一个三分量的三份量`1/1/1 2/2/1 3/3/1` 共9个分量, 每三个分量确定一个点, 三个分量确定一个三角面.  

每个点的三个信息分别是上面表述的坐标,UV,法线.

上面这些数据已经定义完毕了, 所以只需要一个int索引就可以查找到,这就是为什么叫索引列表

> 也可以叫顶点法线
 
#### 切线

TODO ML

#### 顶点色

TODO ML

### 变换矩阵

#### 世界变换矩阵
#### VP矩阵(摄像机位置,FOV等参数)

### 灯光材质参数

### Shader
#### 材质参数
#### 灯光信息

## 绘制调用

开始传递最后的信息

![6CPU渲染-调用绘制-Kerry佬][6CPU渲染-调用绘制-Kerry佬]

### SetPassCall
 
设置渲染数据,告知GPU使用哪个Shader,那种混合模式

### DrawCall

使用那些模型数据

# GPU渲染管线

![7GPU渲染管线-Kerry佬][7GPU渲染管线-Kerry佬]

![8GPU渲染管线2-Kerry佬][8GPU渲染管线2-Kerry佬]

## 简单描述

1. 获取从CPU传来的数据,得到模型空间顶点
2. 调用顶点Shader,转化为裁剪空间
3. 通过视口变换,转化为屏幕空间坐标(2D)
4. 图元装配,变为图元
5. 光栅化,变为片段(片元)
6. 片段Shader,给片段着色
7. 输出合并,变为2D像素

## Shader例子

```Shader
Shader "Kerry/FuxkingShader"
{
    Properties
    {
        _MainTex("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags {"RenderType" = "Opaque"}
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f Vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;
                return 0;
            }
            fixed4 frag (v2f i) : SV_Target
            {
                fixed4 col = tex2D(_MainTex, i.uv);
            }
            ENDCG
        }
    }
}
```

`appdata` 这个结构中就是来自CPU的数据, 坐标和UV  
`Vert` 是顶点Shader  
`v2f` 则是经过顶点Shader后输出的参数,最重要的就是变化后的裁剪坐标  
`frag` 是片元Shader,确定片元的颜色

## 顶点处理 

最重要的任务是将顶点坐标转化为裁剪空间坐标  
也就是模拟拍照的过程,将3D模型进行变形  
经过顶点Shader处理后, 相机金字塔状的视锥体转换变形成一个比例为2:2:1的立方体CVV)

> 顶点Shader不产生2D图像,仅使场景中的3D对象产生变形效果

模型空间(Object Space)通过`ModelMatrix`转化为世界空间(World Space)  
再通过`View Matrix` 转化为相机空间(View Space)  
最后通过`Projection Matrix` 转化为裁剪空间(Clip Space)

![9GPU渲染管线-顶点Shader-Kerry佬][9GPU渲染管线-顶点Shader-Kerry佬]  
![10GPU渲染管线-顶点Shader2-Kerry佬][10GPU渲染管线-顶点Shader2-Kerry佬]

TODO ML 34分

## 图元装配及光栅化
## 片元处理



## 输出合并

# 帧缓冲区

临时画布, 和屏幕一样,但不显示在用户视野中

# 后处理

# 后处理后的GPU渲染

# 输出到目标

也就是成为一帧

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

<!-- 链接 -->
[【教程】技术美术入门：渲染管线概述]:https://www.bilibili.com/video/BV1Q54y1G7v3?from=search&seid=14214151069052570126 "【教程】技术美术入门：渲染管线概述"
<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
