---
title: 渲染管线概述
date: 2021-10-31 14:54:00
updated: 2021-10-31 14:54:00
id: ml-20211031-145400-g165
categories:
	- 渲染管线
tags: 
	- 渲染管线
---

[【教程】技术美术入门：渲染管线概述][【教程】技术美术入门：渲染管线概述]

![1UnityBuild-In渲染管线-Kerry佬][1UnityBuild-In渲染管线-Kerry佬]

<!--more-->

# 渲染管线概述

> 看`ame101`,`shader入门精要`

渲染是将模型生成为图像的操作,分为离线(电影)和实时(游戏)

> 简单来说就是我们将模型,贴图,等一系列信息交付给渲染管线,他就做一些规定好的流程来转化为图像  
> 就像一般的生命周期概念,什么时间做什么事情

**软件和硬件的不同,会导致渲染管线的步骤流程不同**,不存在全世界通用的渲染管线这种标准

当然,我们肯定是以Unity渲染管线为例子,分为`CPU`和`GPU`, 一般说的都是指`GPU`渲染,但实际CPU也在里面出了很多力的

蓝色部分是CPU的工作,绿色是GPU做的

有点像是按下快门,之后会有一张图片出来,也就是一份2D像素点集.

*如何处理多摄像机情况呢*

同深度的情况下渲染后来的摄像机内容,主要是由于摄像机在渲染前会进行清除指令, 摄像机组件上有一个属性`Clear Flags` 用于指定不清除什么, 一般是不清天空盒

层级`Depth`越小越先渲染, 然后后渲染的执行清除,在继续渲染. 所以看到的画面往往是后出现的摄像机内容

# CPU渲染管线

## 剔除(Culling)

要渲染谁

![2CPU渲染-剔除-Kerry佬][2CPU渲染-剔除-Kerry佬]

### 视锥体(Frustum Culling)

依据摄相机参数`FOV(视角)`,`CelipPingPlanes近裁面和远裁面`组成一个锥台, 物体与锥台相碰撞,不在其内的就被剔除

但是对于复杂模型,碰撞性能消耗很大,所以通常会给一个AABB(BoundDing Box)包围盒

### 层级剔除(Layer Culling Mask)

在Unity的Camera中有`CullingMask`不在此范围内的层级不会被此Camera渲染

> 物体的层级由`Layer`属性指定

## 遮挡剔除(Occlusion Culling)

在GameObject的`Tag`中选择`Occlusion Static `和` Occludee Static`

其中透明物体，以及小物件，都不可能阻挡其他的东西，应标记为`Occludees`

这意味着它们将被视为能被其他物体遮挡，但不会被视为作为遮挡物自身，这将有助于减少计算量

#### 窗口操作(Window->Occlusion Culling)

打开遮挡剔除窗口`Window->Occlusion Culling`

> TODO ML 具体窗口操作待完善,需看文档,实际操作

感觉类似寻路, 需要预处理

## 排序(Sort)

按什么顺序渲染

> 确认顺序后,就要逐个*提交到GPU*了.

![3CPU渲染-排序-Kerry佬][3CPU渲染-排序-Kerry佬]

### 渲染顺序(RenderQueue)

一般可以在材质中指定这个数值

通过是否是透明队列来决定排序规则, 排序数值是与摄像机的距离

不透明的话,后渲染的物体由于距离较远,被覆盖的部分在2D的时候不会显示,所以不用处理,有性能优化

半透明的则需要叠色,所以要从后往前,全部渲染,开销较大  
而且对于半透明的物体,还有一个渲染的正确性的问题,叠放的顺序不一样,颜色时会有很大差异的

#### 不透明队列(RenderQueue < 2500)

> 实际是`RenderQueue <= 2500`, 但不建议使用2500这个关键值

摄像机从前往后渲染

#### 半透明队列(RenderQueue > 2500)

摄像机从后往前渲染

> 但是,只能保证物体与物体的顺序为从后往前.  
> 对于物体内部的复杂结构,则很难处理, 是目前的前沿领域, 所以*看到半透明物体的奇怪表现,可以怀疑一下内部复杂排序*

> 遇到这种问题, 解决方法有几种`完全不用半透明`, `选取一些部分不使用半透明`,`定制渲染管线自己对顶点排序`

## 打包数据(Batch)

![4CPU渲染-打包数据-Kerry佬][4CPU渲染-打包数据-Kerry佬]

### 模型信息

模型的本质是什么

一般建模软件使用四边形方式建模,但是游戏软件识别后都是三角面,这是为了适配手机

![5CPU渲染-打包数据-模型的源码-Kerry佬][5CPU渲染-打包数据-模型的源码-Kerry佬]

#### 顶点坐标(Vertices)

可以看到,源码中的第一部分就是顶点坐标,一个立方体共8个顶点, 每个顶点有XYZ三个坐标数据

所以最后一句是`8Vertices`

#### 法线(vertex normals)

这里写着`6 vertex normals`

通过建模软件可以看到, 每个顶点实际关联三个面,所以应该有三条法线  
但实际每个面的四条法线是重复的,所以被合并成了一条法线,6个面就是6条法线

#### UV(texture coords)

`4 texture coords`

UV是一组记录着模型上的贴图应该怎么贴，贴在那里的数据

也是由于重复, 数据只有4条

> UV是一个二维数据, 第三个分量是没用的,可以删除

#### 索引列表 (polygons triangles)

`0 polygons - 12 triangles`

表示0多边形 12个三角面.

用于规定那些数据组成一个三角面  
一个三角形包含一个三分量的三份量`1/1/1 2/2/1 3/3/1` 共9个分量, 每三个分量确定一个点, 三个分量确定一个三角面.  

每个点的三个信息分别是上面表述的坐标,UV,法线.

上面这些数据已经定义完毕了, 所以只需要一个int索引就可以查找到,这就是为什么叫索引列表

> 也可以叫顶点法线
 
#### 切线

TODO ML

#### 顶点色

### 变换矩阵

#### 世界变换矩阵
#### VP矩阵(摄像机位置,FOV等参数)

### 灯光材质参数

### Shader
#### 材质参数
#### 灯光信息

TODO ML

## 绘制调用

开始传递最后的信息

![6CPU渲染-调用绘制-Kerry佬][6CPU渲染-调用绘制-Kerry佬]

### SetPassCall
 
设置渲染数据,告知GPU使用哪个Shader,那种混合模式

### DrawCall

使用那些模型数据

# GPU渲染管线

![7GPU渲染管线-Kerry佬][7GPU渲染管线-Kerry佬]

![8GPU渲染管线2-Kerry佬][8GPU渲染管线2-Kerry佬]

## 简单描述

1. 获取从CPU传来的数据,得到模型空间顶点
2. 调用顶点Shader,转化为裁剪空间
3. 通过视口变换,转化为屏幕空间坐标(2D)
4. 图元装配,变为图元
5. 光栅化,变为片段(片元)
6. 片段Shader,给片段着色
7. 输出合并,变为2D像素

## Shader例子

![9GPU渲染管线-Shader与GPU的关系-Kerry佬][9GPU渲染管线-Shader与GPU的关系-Kerry佬]

```Shader
Shader "Kerry/FuxkingShader"
{
    Properties
    {
        _MainTex("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags {"RenderType" = "Opaque"}
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 texcoord : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f Vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;
                return 0;
            }
            fixed4 frag (v2f i) : SV_Target
            {
                fixed4 col = tex2D(_MainTex, i.uv);
            }
            ENDCG
        }
    }
}
```

`appdata` 这个结构中就是来自CPU的数据, 坐标和UV  
`Vert` 是顶点Shader  
`v2f` 则是经过顶点Shader后输出的参数,最重要的就是变化后的裁剪坐标  
`frag` 是片元Shader,确定片元的颜色

## 顶点处理 

最重要的任务是将顶点坐标转化为裁剪空间坐标  
也就是模拟拍照的过程,将3D模型进行变形  
**经过顶点Shader处理后, 相机金字塔状的视锥体转换变形成一个比例为2:2:1的立方体CVV)**

> 顶点Shader不产生2D图像,仅使场景中的3D对象产生变形效果

*模型空间(Object Space)*通过`ModelMatrix`转化为*世界空间(World Space)*  
再通过`View Matrix` 转化为*相机空间(View Space)*  
最后通过`Projection Matrix` 转化为*裁剪空间(Clip Space)*

![10GPU渲染管线-顶点Shader-Kerry佬][10GPU渲染管线-顶点Shader-Kerry佬]  
![11GPU渲染管线-顶点Shader2-Kerry佬][11GPU渲染管线-顶点Shader2-Kerry佬]
![12GPU渲染管线-顶点Shader3-Kerry佬][12GPU渲染管线-顶点Shader3-Kerry佬]


## 图元装配及光栅化

![13GPU渲染管线-硬件操作阶段-图元装配及光栅化-Kerry佬][13GPU渲染管线-硬件操作阶段-图元装配及光栅化-Kerry佬]

*裁剪空间(Clip Space)*进行*裁剪操作(ViewFrustumClipping)*  
相比于视锥体剔除(针对物体)，这里主要是针对三角面的截断， 会重新生成新的三角面

然后通过*透视除法(除w)*将原本`(-w,-w,w)到(w,w,0)`的坐标系转化为`(-1,-1,1)到(1,1,0)`的*NDC标准坐标系*

然后处理*背面剔除(BackFaceCulling)*   
然后通过相机角度观察,之前的索引列表形成的三角面,其三个点是顺时针还是逆时针.  
顺时针就是背面，逆时针就是正面

> 这里与右手坐标系和左手坐标系相关.

*视口转换*依据屏幕像素将之前的*NDC标准坐标系*变为*屏幕坐标(ScreenSpace)*  
此处只针对XY坐标,Z坐标(深度)后面还有用处.

## 图元装配

![14GPU渲染管线-硬件操作阶段-图元装配及光栅化2-Kerry佬][14GPU渲染管线-硬件操作阶段-图元装配及光栅化2-Kerry佬]

之前的所有操作,都是对于顶点的操作,目前还是没有线的.  
图元装配就是要将这些点进行连线,之后形成一个个三角形,最终在这些三角形中填充片元.

> 之前的Z值就存储与每个片元上,作为深度使用.  
> 主要就是使用插值生成,包括深度和颜色

插值就有斜线,然后就生成锯齿.

依据顶点Shader处理后的数据,**现在每个片元上还带有之前的自定义数据**.

## 片元处理

每个片元都会调用**片元Shader**  

最重要的任务是**上色**  

*纹理Texturing*和*光照Lighting*的处理



TODO ML 55min


## 输出合并

# 帧缓冲区

临时画布, 和屏幕一样,但不显示在用户视野中

# 后处理

# 后处理后的GPU渲染

# 输出到目标

也就是成为一帧

# 完毕

**感谢您的观看!**  
本文来自 [ML-Blog][ML-Blog_Link]

<!-- 图片 -->

[1UnityBuild-In渲染管线-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/1UnityBuild-In%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-Kerry%E4%BD%AC.png?raw=true "1UnityBuild-In渲染管线-Kerry佬"
[2CPU渲染-剔除-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/2CPU%E6%B8%B2%E6%9F%93-%E5%89%94%E9%99%A4-Kerry%E4%BD%AC.png?raw=true "2CPU渲染-剔除-Kerry佬"
[3CPU渲染-排序-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/3CPU%E6%B8%B2%E6%9F%93-%E6%8E%92%E5%BA%8F-Kerry%E4%BD%AC.png?raw=true "3CPU渲染-排序-Kerry佬"
[4CPU渲染-打包数据-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/4CPU%E6%B8%B2%E6%9F%93-%E6%89%93%E5%8C%85%E6%95%B0%E6%8D%AE-Kerry%E4%BD%AC.png?raw=true "4CPU渲染-打包数据-Kerry佬"
[5CPU渲染-打包数据-模型的源码-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/5CPU%E6%B8%B2%E6%9F%93-%E6%89%93%E5%8C%85%E6%95%B0%E6%8D%AE-%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BA%90%E7%A0%81-Kerry%E4%BD%AC.png?raw=true "5CPU渲染-打包数据-模型的源码-Kerry佬"
[6CPU渲染-调用绘制-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/6CPU%E6%B8%B2%E6%9F%93-%E8%B0%83%E7%94%A8%E7%BB%98%E5%88%B6-Kerry%E4%BD%AC.png?raw=true "6CPU渲染-调用绘制-Kerry佬"
[7GPU渲染管线-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/7GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-Kerry%E4%BD%AC.png?raw=true "7GPU渲染管线-Kerry佬"
[8GPU渲染管线2-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/8GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF2-Kerry%E4%BD%AC.png?raw=true "8GPU渲染管线2-Kerry佬"
[9GPU渲染管线-Shader与GPU的关系-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/9GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-Shader%E4%B8%8EGPU%E7%9A%84%E5%85%B3%E7%B3%BB-Kerry%E4%BD%AC.png?raw=true "9GPU渲染管线-Shader与GPU的关系-Kerry佬"
[10GPU渲染管线-顶点Shader-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/10GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E9%A1%B6%E7%82%B9Shader-Kerry%E4%BD%AC.png?raw=true "10GPU渲染管线-顶点Shader-Kerry佬"
[11GPU渲染管线-顶点Shader2-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/11GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E9%A1%B6%E7%82%B9Shader2-Kerry%E4%BD%AC.png?raw=true "11GPU渲染管线-顶点Shader2-Kerry佬"
[12GPU渲染管线-顶点Shader3-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/12GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E9%A1%B6%E7%82%B9Shader3-Kerry%E4%BD%AC.png?raw=true "12GPU渲染管线-顶点Shader3-Kerry佬"
[13GPU渲染管线-硬件操作阶段-图元装配及光栅化-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/13GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5-%E5%9B%BE%E5%85%83%E8%A3%85%E9%85%8D%E5%8F%8A%E5%85%89%E6%A0%85%E5%8C%96-Kerry%E4%BD%AC.png?raw=true "13GPU渲染管线-硬件操作阶段-图元装配及光栅化-Kerry佬"
[14GPU渲染管线-硬件操作阶段-图元装配及光栅化2-Kerry佬]:https://github.com/UserMingHaoLi/ML_HexoBlogContentImages/blob/main/Content/Unity%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/14GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-%E7%A1%AC%E4%BB%B6%E6%93%8D%E4%BD%9C%E9%98%B6%E6%AE%B5-%E5%9B%BE%E5%85%83%E8%A3%85%E9%85%8D%E5%8F%8A%E5%85%89%E6%A0%85%E5%8C%962-Kerry%E4%BD%AC.png?raw=true "14GPU渲染管线-硬件操作阶段-图元装配及光栅化2-Kerry佬"

<!-- 链接 -->
[【教程】技术美术入门：渲染管线概述]:https://www.bilibili.com/video/BV1Q54y1G7v3?from=search&seid=14214151069052570126 "【教程】技术美术入门：渲染管线概述"
<!-- 水印 -->
[ML-Blog_Link]:https://userminghaoli.github.io/ "我的博客"
